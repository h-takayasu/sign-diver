<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Sign Diverã®ã‚²ãƒ¼ãƒ ç”»é¢ã€‚ã‚«ãƒ¡ãƒ©ã§æŒ‡æ–‡å­—ã‚’èªè­˜ã—ã¦ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ï¼æ·±æµ·ã‚’ç›®æŒ‡ã—ã¦æ–‡å­—æ•°ã‚’ç¨¼ã”ã†ã€‚">
  <meta name="robots" content="noindex">
  <title>ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ - æŒ‡æ–‡å­—ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚²ãƒ¼ãƒ  Sign Diver</title>
  <!-- ææ¡ˆ3a: DNSè§£æ±ºï¼‹TLSæ¥ç¶šã‚’äº‹å‰ç¢ºç«‹ -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="preconnect" href="https://storage.googleapis.com" crossorigin>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', 'Arial', sans-serif;
      background: linear-gradient(135deg, #e0f7ff 0%, #b3e5fc 50%, #81d4fa 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      gap: 16px;
      position: relative;
      overflow-x: hidden;
    }
    
    /* èƒŒæ™¯ã®æ³¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(circle at 20% 80%, rgba(255,255,255,0.3) 3px, transparent 3px),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,0.25) 4px, transparent 4px),
        radial-gradient(circle at 40% 40%, rgba(255,255,255,0.3) 2px, transparent 2px),
        radial-gradient(circle at 60% 70%, rgba(255,255,255,0.25) 5px, transparent 5px);
      background-size: 200px 200px, 300px 300px, 250px 250px, 350px 350px;
      animation: bubbleFloat 25s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }
    
    @keyframes bubbleFloat {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(10px, -20px); }
      50% { transform: translate(-5px, -40px); }
      75% { transform: translate(15px, -30px); }
    }
    
    /* ãƒ•ãƒƒã‚¿ãƒ¼ */
    .site-footer {
      width: 100%;
      max-width: 1000px;
      text-align: center;
      padding: 10px 0 4px;
      position: relative;
      z-index: 1;
    }
    
    .site-footer a {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: #0288d1;
      text-decoration: none;
      font-size: 13px;
      letter-spacing: 0.5px;
      transition: color 0.2s;
      font-weight: 600;
    }
    
    .site-footer a:hover {
      color: #0277bd;
    }
    
    .footer-icon {
      font-size: 11px;
      color: #ef5350;
    }
    
    .footer-name {
      font-weight: 500;
    }
    
    .game-container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(100, 181, 246, 0.3);
      border-radius: 30px;
      box-shadow: 
        0 10px 40px rgba(100, 181, 246, 0.3),
        0 0 0 1px rgba(255,255,255,0.8) inset;
      max-width: 1000px;
      width: 100%;
      overflow: hidden;
      position: relative;
      z-index: 1;
    }
    
    /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
    .game-header {
      background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%);
      color: white;
      padding: 14px 20px 0;
      border-bottom: 2px solid rgba(255, 255, 255, 0.5);
    }
    
    .game-header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .timer {
      font-size: 22px;
      font-weight: bold;
    }
    
    .score {
      font-size: 22px;
      font-weight: bold;
    }
    
    .stats {
      font-size: 13px;
      opacity: 0.85;
    }
    
    /* å…¨ä½“ã‚¿ã‚¤ãƒãƒ¼ãƒãƒ¼ */
    .total-timer-bar-wrap {
      position: relative;
      height: 10px;
      background: rgba(0,0,0,0.3);
    }
    
    .total-timer-bar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #a8edea, #fed6e3);
      transition: width 1s linear, background 1s;
      transform-origin: left;
    }
    
    .total-timer-bar.warning {
      background: linear-gradient(90deg, #f7971e, #ffd200);
    }
    
    .total-timer-bar.danger {
      background: linear-gradient(90deg, #f44336, #ff6b6b);
      animation: barPulse 0.5s ease-in-out infinite alternate;
    }
    
    /* å˜èªã‚¿ã‚¤ãƒãƒ¼ãƒãƒ¼ */
    .word-timer-bar-wrap {
      position: relative;
      height: 12px;
      background: rgba(0,0,0,0.4);
    }
    
    .word-timer-bar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #4facfe, #00f2fe);
      transition: width 1s linear, background 0.5s;
    }
    
    .word-timer-bar.warning {
      background: linear-gradient(90deg, #f7971e, #ffd200);
    }
    
    .word-timer-bar.danger {
      background: linear-gradient(90deg, #f44336, #ff6b6b);
      animation: barPulse 0.4s ease-in-out infinite alternate;
    }
    
    /* ã‚³ãƒ³ãƒœåŸºæº–ãƒãƒ¼ã‚«ãƒ¼ï¼ˆ50%ä½ç½®ï¼‰ */
    .combo-marker {
      position: absolute;
      top: 0;
      height: 100%;
      width: 3px;
      background: #ffd700;
      box-shadow: 0 0 6px rgba(255, 215, 0, 0.9), 0 0 12px rgba(255, 215, 0, 0.5);
      z-index: 2;
      pointer-events: none;
    }
    
    /* ãƒãƒ¼ã‚«ãƒ¼ã®ä¸Šã®ä¸‰è§’ãƒ©ãƒ™ãƒ« */
    .combo-marker::before {
      content: 'COMBO';
      position: absolute;
      bottom: calc(100% + 3px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      font-weight: bold;
      color: #ffd700;
      letter-spacing: 0.5px;
      white-space: nowrap;
      text-shadow: 0 0 6px rgba(255, 215, 0, 0.8);
    }
    
    /* ãƒãƒ¼ã‚«ãƒ¼ã®ä¸‹ä¸‰è§’ */
    .combo-marker::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 5px solid #ffd700;
    }
    
    @keyframes barPulse {
      from { opacity: 1; }
      to   { opacity: 0.5; }
    }
    
    /* å•é¡Œè¡¨ç¤ºã‚¨ãƒªã‚¢ */
    .word-display {
      padding: 40px 20px;
      text-align: center;
      background: #000;
      position: relative;
      overflow: hidden;
      height: 200px;      /* min-heightã‹ã‚‰heightã«å¤‰æ›´ã—ã¦ç¸¦ã‚µã‚¤ã‚ºã‚’å›ºå®š */
      box-sizing: border-box;
    }
    
    /* æ·±æµ·ã‚­ãƒ£ãƒ³ãƒã‚¹ */
    #seaCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    /* æ·±åº¦ãƒ¡ãƒ¼ã‚¿ãƒ¼ */
    .depth-meter {
      position: absolute;
      top: 10px;
      right: 14px;
      font-size: 11px;
      color: rgba(180, 220, 255, 0.7);
      letter-spacing: 1px;
      z-index: 2;
      font-family: monospace;
    }
    
    /* word-displayå†…ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å‰é¢ã« */
    .word-display > :not(#seaCanvas) {
      position: relative;
      z-index: 2;
    }
    
    /* â•â•â• ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ â•â•â• */
    .tutorial-overlay {
      position: fixed;
      inset: 0;
      background: rgba(6, 14, 30, 0.92);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9800;
    }
    .tutorial-box {
      background: linear-gradient(160deg, rgba(20,40,80,0.95), rgba(10,25,55,0.98));
      border: 2px solid rgba(79,172,254,0.45);
      border-radius: 28px;
      padding: 40px 44px 32px;
      max-width: 460px;
      width: 90%;
      text-align: center;
      box-shadow: 0 0 60px rgba(79,172,254,0.15), 0 24px 48px rgba(0,0,0,0.6);
      animation: tutBoxIn 0.4s cubic-bezier(0.22,1,0.36,1) forwards;
    }
    @keyframes tutBoxIn {
      0%   { transform: translateY(28px) scale(0.97); opacity: 0; }
      100% { transform: translateY(0)    scale(1);    opacity: 1; }
    }
    .tutorial-icon  { font-size: 44px; margin-bottom: 10px; }
    .tutorial-title {
      font-size: 19px; font-weight: 800; color: #4facfe;
      letter-spacing: 3px; margin-bottom: 22px;
    }
    .tutorial-tips {
      list-style: none; margin: 0 0 26px; padding: 0; text-align: left;
    }
    .tutorial-tips li {
      display: flex; align-items: flex-start; gap: 10px;
      font-size: 14.5px; color: rgba(255,255,255,0.86);
      line-height: 1.65; margin-bottom: 13px;
    }
    .tutorial-tips li .ti { font-size: 18px; flex-shrink: 0; margin-top: 1px; }
    .tutorial-tips strong { color: #4facfe; }
    .tutorial-ok-btn {
      padding: 14px 52px;
      background: linear-gradient(135deg, #4facfe 0%, #1976d2 100%);
      color: #fff; border: none; border-radius: 50px;
      font-size: 17px; font-weight: 800; cursor: pointer;
      letter-spacing: 2px;
      box-shadow: 0 6px 22px rgba(79,172,254,0.45);
      transition: transform .2s, box-shadow .2s;
    }
    .tutorial-ok-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(79,172,254,0.55);
    }
    .tutorial-skip {
      display: block; margin-top: 13px;
      font-size: 11.5px; color: rgba(255,255,255,0.28);
      cursor: pointer; letter-spacing: 0.5px; transition: color .2s;
    }
    .tutorial-skip:hover { color: rgba(255,255,255,0.55); }
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .countdown-overlay {
      position: fixed;
      inset: 0;
      background: rgba(10, 20, 40, 0.82);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9000;
      /* èƒŒæ™¯è‡ªä½“ã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã—ãªã„ */
    }
    
    /* æ•°å­—éƒ¨åˆ†ã ã‘ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    .countdown-number {
      font-size: 120px;
      font-weight: 900;
      color: #4facfe;
      letter-spacing: 4px;
      animation: countdownPulse 0.6s cubic-bezier(0.22,1,0.36,1) forwards;
    }
    
    .countdown-number.start {
      color: #4caf50;
      font-size: 80px;
      letter-spacing: 8px;
      animation: startBurst 0.5s cubic-bezier(0.22,1,0.36,1) forwards;
    }
    
    @keyframes countdownPulse {
      0%   { transform: scale(0.3); opacity: 0; }
      60%  { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1);   opacity: 1; }
    }
    
    @keyframes startBurst {
      0%   { transform: scale(0.6) translateY(20px); opacity: 0; }
      100% { transform: scale(1)   translateY(0);    opacity: 1; }
    }
    
    .current-word {
      font-size: 48px;
      font-weight: bold;
      letter-spacing: 4px;
      min-height: 60px;
      margin-bottom: 15px;
      color: #fff;
      text-shadow: 0 2px 12px rgba(0,0,0,0.8), 0 0 30px rgba(0,0,0,0.5);
    }
    
    .hiragana-display {
      font-size: 24px;
      letter-spacing: 2px;
      color: rgba(255, 255, 255, 0.85);
      font-weight: normal;
      text-shadow: 0 1px 8px rgba(0,0,0,0.8);
    }
    
    .hiragana-char {
      display: inline-block;
      margin: 0 1px;
      transition: all 0.2s;
    }
    
    /* å…¥åŠ›æ¸ˆã¿ï¼šæš—ã‚ã®ç™½ã§ç›®ç«‹ãŸã›ãªã„ */
    .hiragana-char.completed {
      color: rgba(255, 255, 255, 0.3);
      opacity: 0.5;
    }
    
    /* ç¾åœ¨å…¥åŠ›ä¸­ï¼šé»„è‰²ï¼‹ç™ºå…‰ â†’ ã©ã®èƒŒæ™¯ã§ã‚‚æœ€ã‚‚ç›®ç«‹ã¤ */
    .hiragana-char.current {
      color: #ffe066;
      font-weight: bold;
      border-bottom: 3px solid #ffe066;
      text-shadow: 0 0 10px rgba(255,220,50,0.9), 0 0 20px rgba(255,180,0,0.6);
      animation: pulse 1s infinite;
    }
    
    /* æœªå…¥åŠ›ï¼šç™½ï¼‹å½±ã§èƒŒæ™¯ã‹ã‚‰æµ®ã‹ã›ã‚‹ */
    .hiragana-char.pending {
      color: #fff;
      text-shadow: 0 1px 8px rgba(0,0,0,0.9);
    }
    
    .char {
      display: inline-block;
      margin: 0 2px;
      transition: all 0.2s;
    }
    
    /* å…¥åŠ›æ¸ˆã¿ï¼šé»„ç·‘ã§ã¯ãªãç™½ç³»ã«ã—ã¦é’èƒŒæ™¯ã§ã‚‚è¦‹ãˆã‚‹ */
    .char.completed {
      color: rgba(255, 255, 255, 0.45);
      text-shadow: none;
    }
    
    /* ç¾åœ¨å…¥åŠ›ä¸­ï¼šé»„è‰²ç™ºå…‰ */
    .char.current {
      color: #ffe066;
      text-shadow: 0 0 12px rgba(255,220,50,0.9), 0 0 24px rgba(255,180,0,0.5);
    }
    
    /* æœªå…¥åŠ›ï¼šç™½ï¼‹å½± */
    .char.pending {
      color: #fff;
      text-shadow: 0 2px 10px rgba(0,0,0,0.9);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    @keyframes comboPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    @keyframes comboEffect {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8) translateY(-50px);
      }
    }
    
    @keyframes ngEffect {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      40% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
      }
    }
    
    /* å‰Šé™¤: ngFlashã¯ä½¿ã‚ãªã„ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ï¼‰ */
    
    /* ã‚«ãƒ¡ãƒ©ï¼†èªè­˜ã‚¨ãƒªã‚¢ */
    .game-main {
      display: flex;
      padding: 20px;
      gap: 20px;
    }
    
    .camera-area {
      flex: 2;
    }
    .camera-area.hidden {
      display: none;
    }
    
    video {
      display: none;
    }
    
    /* ã‚«ãƒ¡ãƒ©ç”¨canvasï¼ˆseaCanvasã¯é™¤å¤–ï¼‰ */
    canvas:not(#seaCanvas) {
      width: 100%;
      max-width: 640px;
      border-radius: 12px;
      border: 2px solid #ddd;
      background: #000;
    }
    
    /* æ·±æµ·ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯è¦ªè¦ç´ ã‚’å®Œå…¨ã«åŸ‹ã‚ã‚‹ */
    #seaCanvas {
      display: block;
      width: 100% !important;
      max-width: none !important;
      border: none !important;
      border-radius: 0 !important;
      background: transparent !important;
    }
    
    .recognition-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .recognition-result {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      text-align: center;
    }
    
    .recognized-char {
      font-size: 64px;
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
    }
    
    .confidence {
      font-size: 18px;
      color: #666;
    }
    
    .status-box {
      background: #e3f2fd;
      border-radius: 12px;
      padding: 15px;
      font-size: 14px;
      line-height: 1.6;
    }
    
    /* çµæœç”»é¢ */
    .result-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .result-screen.show {
      display: flex;
    }
    
    .result-content {
      background: white;
      border-radius: 20px;
      padding: 40px;
      max-width: 500px;
      width: 90%;
      text-align: center;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .result-title {
      font-size: 36px;
      margin-bottom: 30px;
      color: #333;
    }
    
    .result-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .stat-item {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
    }
    
    .stat-label {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }
    
    .stat-value {
      font-size: 32px;
      font-weight: bold;
      color: #333;
    }
    
    .title-display {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      color: white;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .title-emoji {
      font-size: 48px;
      margin-bottom: 10px;
    }
    
    .title-text {
      font-size: 28px;
      font-weight: bold;
    }
    
    /* åˆ°é”ã‚¹ãƒ†ãƒ¼ã‚¸è¡¨ç¤º */
    .stage-result {
      background: linear-gradient(135deg, rgba(79,172,254,0.15), rgba(0,180,220,0.12));
      border: 1px solid rgba(79,172,254,0.3);
      border-radius: 14px;
      padding: 20px;
      margin-bottom: 20px;
      display: grid;
      grid-template-columns: auto 1fr;
      grid-template-rows: auto auto;
      gap: 12px 16px;
      align-items: center;
    }
    
    .stage-result-icon {
      grid-row: 1 / 3;
      font-size: 56px;
      text-align: center;
    }
    
    .stage-result-info {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    
    .stage-result-name {
      font-size: 24px;
      font-weight: 700;
      color: #4facfe;
      text-shadow: 0 0 12px rgba(79,172,254,0.5);
    }
    
    .stage-result-depth {
      font-size: 16px;
      font-weight: 600;
      color: rgba(0,0,0,0.6);
    }
    
    .stage-result-comment {
      grid-column: 2;
      font-size: 14px;
      line-height: 1.6;
      color: rgba(0,0,0,0.7);
    }
    
    .high-score-notice {
      background: #fff3cd;
      color: #856404;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-weight: bold;
    }
    
    .result-actions {
      display: flex;
      gap: 15px;
      justify-content: center;
    }
    
    .result-btn {
      padding: 15px 30px;
      font-size: 18px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
    }
    
    .retry-btn {
      background: #4caf50;
      color: white;
    }
    
    .retry-btn:hover {
      background: #45a049;
      transform: translateY(-2px);
    }
    
    .share-btns {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 4px;
    }

    .share-btn {
      padding: 10px 20px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .share-btn-x {
      background: #000;
      color: #fff;
    }

    .share-btn-x:hover {
      background: #333;
    }

    .share-btn-line {
      background: #06C755;
      color: #fff;
    }

    .share-btn-line:hover {
      background: #05a847;
    }

    .menu-btn {
      background: #757575;
      color: white;
    }

    /* ä¸­æ–­ãƒœã‚¿ãƒ³ */
 .abort-btn {
      display: block;
      width: 100%;
      margin-top: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.6);
      color: #555;
      border: 1.5px solid #ccc;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    .abort-btn:hover {
      background: rgba(255,255,255,0.9);
      border-color: #aaa;
      color: #333;
    }
    
    .menu-btn:hover {
      background: #616161;
      transform: translateY(-2px);
    }
    
    /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
      padding: 40px 24px;
      background: linear-gradient(160deg, #0a1628 0%, #0d2140 50%, #0a1628 100%);
      color: #fff;
    }

    .loading-title {
      font-size: 15px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 32px;
    }

    .tips-card {
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 28px 32px;
      max-width: 480px;
      width: 100%;
      margin-bottom: 32px;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      transition: opacity 0.4s ease;
    }

    .tips-emoji {
      font-size: 40px;
      line-height: 1;
    }

    .tips-text {
      font-size: 15px;
      color: rgba(255,255,255,0.85);
      line-height: 1.7;
      font-weight: 500;
    }

    .tips-counter {
      font-size: 12px;
      color: rgba(255,255,255,0.3);
      letter-spacing: 1px;
      margin-bottom: 16px;
    }

    .loading-progress {
      font-size: 13px;
      color: rgba(255,255,255,0.4);
      letter-spacing: 0.5px;
    }

    .loading-bar-wrap {
      width: 200px;
      height: 3px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      margin-top: 16px;
      overflow: hidden;
    }

    .loading-bar {
      height: 100%;
      width: 30%;
      background: linear-gradient(90deg, #4facfe, #00f2fe);
      border-radius: 2px;
      animation: loadingPulse 1.8s ease-in-out infinite;
    }

    @keyframes loadingPulse {
      0%   { transform: translateX(-100%); }
      100% { transform: translateX(400%); }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ã‚¹ãƒãƒ›å¯¾å¿œ (max-width: 640px)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    @media (max-width: 640px) {

      /* â”€â”€ ãƒœãƒ‡ã‚£ãƒ»å…¨ä½“ â”€â”€ */
      body {
        padding: 0;
        align-items: stretch;
      }

      .game-container {
        border-radius: 0;
        border-left: none;
        border-right: none;
        max-width: 100%;
      }

      /* â”€â”€ ãƒ˜ãƒƒãƒ€ãƒ¼ â”€â”€ */
      .game-header {
        padding: 10px 12px 0;
      }

      .game-header-top {
        margin-bottom: 8px;
      }

      .timer, .score {
        font-size: 17px;
      }

      .stats {
        font-size: 11px;
      }

      /* â”€â”€ å•é¡Œè¡¨ç¤ºã‚¨ãƒªã‚¢ â”€â”€ */
      .word-display {
        height: 140px;
        padding: 20px 12px;
      }

      .current-word {
        font-size: 28px;
        letter-spacing: 2px;
        margin-bottom: 8px;
        min-height: 36px;
        /* é•·ã„æ–‡å­—åˆ—ãŒç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†æŠ˜ã‚Šè¿”ã— */
        white-space: normal;
        word-break: break-all;
        line-height: 1.2;
      }

      .hiragana-display {
        font-size: 16px;
        letter-spacing: 1px;
        white-space: normal;
        word-break: break-all;
        line-height: 1.4;
      }

      .depth-meter {
        font-size: 9px;
        top: 6px;
        right: 8px;
      }

      /* â”€â”€ ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ï¼šæ¨ªä¸¦ã³â†’ç¸¦ç©ã¿ â”€â”€ */
      .game-main {
        flex-direction: column;
        padding: 10px 10px 12px;
        gap: 10px;
      }

      .camera-area {
        flex: none;
        width: 100%;
      }

      /* ã‚«ãƒ¡ãƒ©canvasã‚’ãƒ•ãƒ«å¹…ã« */
      canvas:not(#seaCanvas) {
        max-width: 100%;
        border-radius: 8px;
      }

      /* â”€â”€ èªè­˜ã‚¨ãƒªã‚¢ï¼šæ¨ªä¸¦ã³ã§ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã« â”€â”€ */
      .recognition-area {
        flex-direction: row;
        gap: 8px;
      }

      .recognition-result {
        flex: 1;
        padding: 10px 8px;
        border-radius: 8px;
      }

      .recognized-char {
        font-size: 44px;
        margin-bottom: 4px;
      }

      .confidence {
        font-size: 13px;
      }

      .status-box {
        flex: 1;
        padding: 10px 8px;
        font-size: 12px;
        border-radius: 8px;
        line-height: 1.5;
      }

      /* â”€â”€ çµæœç”»é¢ â”€â”€ */
      .result-content {
        padding: 24px 16px;
        border-radius: 16px;
        width: 94%;
        max-height: 92vh;
        overflow-y: auto;
      }

      .result-title {
        font-size: 24px;
        margin-bottom: 16px;
      }

      .result-stats {
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 16px;
      }

      .stat-item {
        padding: 12px 8px;
        border-radius: 8px;
      }

      .stat-label {
        font-size: 11px;
      }

      .stat-value {
        font-size: 24px;
      }

      .title-display {
        padding: 14px 10px;
        margin-bottom: 12px;
        border-radius: 12px;
      }

      .title-emoji {
        font-size: 36px;
        margin-bottom: 6px;
      }

      .title-text {
        font-size: 20px;
      }

      .stage-result {
        padding: 14px 10px;
        gap: 8px 10px;
        margin-bottom: 12px;
      }

      .stage-result-icon {
        font-size: 40px;
      }

      .stage-result-name {
        font-size: 18px;
      }

      .stage-result-depth {
        font-size: 13px;
      }

      .stage-result-comment {
        font-size: 12px;
      }

      .result-actions {
        gap: 10px;
        flex-wrap: wrap;
      }

      .result-btn {
        padding: 12px 20px;
        font-size: 15px;
        flex: 1;
        min-width: 120px;
      }

      .share-btns {
        gap: 8px;
      }

      .share-btn {
        padding: 9px 14px;
        font-size: 13px;
        flex: 1;
      }

      .high-score-notice {
        padding: 10px;
        font-size: 13px;
        margin-bottom: 12px;
      }

      /* â”€â”€ ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ« â”€â”€ */
      .tutorial-box {
        padding: 28px 20px 24px;
        border-radius: 20px;
      }

      .tutorial-title {
        font-size: 16px;
        margin-bottom: 16px;
      }

      .tutorial-tips li {
        font-size: 13px;
        margin-bottom: 10px;
      }

      .tutorial-ok-btn {
        padding: 12px 32px;
        font-size: 15px;
      }

      /* â”€â”€ ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ â”€â”€ */
      .countdown-number {
        font-size: 80px;
      }

      .countdown-number.start {
        font-size: 56px;
      }

      /* â”€â”€ ãƒ•ãƒƒã‚¿ãƒ¼ â”€â”€ */
      .site-footer {
        padding: 8px 0 6px;
        font-size: 12px;
      }
    }
  
    /* ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼ãƒ»é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« */
    #cameraErrorModal, #cameraSelectModal {
      position: fixed;
      inset: 0;
      z-index: 10000;
      background: rgba(10, 20, 60, 0.82);
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(6px);
    }
    #cameraErrorModal.show, #cameraSelectModal.show {
      display: flex;
    }
    .cam-modal-box {
      background: white;
      border-radius: 20px;
      padding: 32px 28px;
      max-width: 420px;
      width: 90%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,100,0.3);
      border: 2px solid rgba(100,181,246,0.4);
    }
    .cam-modal-icon { font-size: 48px; margin-bottom: 12px; }
    .cam-modal-title {
      font-size: 18px; font-weight: 800;
      color: #1a237e; margin-bottom: 12px;
    }
    .cam-modal-body {
      font-size: 13px; color: #37474f;
      line-height: 1.8; margin-bottom: 20px;
      text-align: left;
    }
    .cam-modal-body b { color: #1565c0; }
    .cam-modal-btn {
      padding: 11px 28px;
      border: none; border-radius: 50px;
      cursor: pointer; font-size: 14px;
      font-weight: 700; margin: 4px;
      transition: all 0.2s;
    }
    .cam-modal-btn.primary {
      background: linear-gradient(135deg, #64b5f6, #1976d2);
      color: white;
      box-shadow: 0 4px 14px rgba(25,118,210,0.4);
    }
    .cam-modal-btn.secondary {
      background: white; color: #555;
      border: 2px solid #ccc;
    }
    .cam-select-list {
      display: flex; flex-direction: column;
      gap: 8px; margin-bottom: 20px;
    }
    .cam-select-item {
      padding: 12px 16px;
      border: 2px solid rgba(100,181,246,0.3);
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px; font-weight: 600;
      color: #1a237e;
      background: rgba(100,181,246,0.08);
      text-align: left;
      transition: all 0.2s;
    }
    .cam-select-item:hover {
      background: rgba(100,181,246,0.2);
      border-color: rgba(100,181,246,0.6);
    }
    .cam-select-item.recommended {
      border: 2px dashed rgba(233,30,99,0.6);
      background: rgba(233,30,99,0.06);
    }
    .cam-select-item.recommended:hover {
      background: rgba(233,30,99,0.12);
      border-color: rgba(233,30,99,0.9);
    }
  </style>
  <link rel="icon" type="image/png" sizes="32x32" href="./asset/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./asset/favicon-16.png">
  <link rel="apple-touch-icon" href="./asset/sign_diver_favicon_512.png">
</head>
<body>
  <!-- ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="cameraErrorModal">
    <div class="cam-modal-box">
      <div class="cam-modal-icon" id="camErrIcon">âš ï¸</div>
      <div class="cam-modal-title" id="camErrTitle">ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼</div>
      <div class="cam-modal-body" id="camErrBody"></div>
      <button class="cam-modal-btn primary" id="camErrRetry">å†è©¦è¡Œ</button>
      <button class="cam-modal-btn secondary" id="camErrSkip">ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã™ã‚‹</button>
    </div>
  </div>

  <!-- ã‚«ãƒ¡ãƒ©é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="cameraSelectModal">
    <div class="cam-modal-box">
      <div class="cam-modal-icon">ğŸ“·</div>
      <div class="cam-modal-title">ã‚«ãƒ¡ãƒ©ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
      <div class="cam-modal-body">è¤‡æ•°ã®ã‚«ãƒ¡ãƒ©ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚ä½¿ç”¨ã™ã‚‹ã‚«ãƒ¡ãƒ©ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</div>
      <div class="cam-select-list" id="camSelectList"></div>
      <button class="cam-modal-btn secondary" id="camSelectSkip">ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã™ã‚‹</button>
    </div>
  </div>

  <div class="game-container">
    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ -->
    <div id="loadingScreen" class="loading-screen">
      <p class="loading-title">ğŸ’¡ æŒ‡æ–‡å­—ã®è±†çŸ¥è­˜</p>
      <div class="tips-card" id="tipsCard">
        <span class="tips-emoji" id="tipsEmoji">ğŸ“–</span>
        <span class="tips-text" id="tipsText">èª­ã¿è¾¼ã¿ä¸­...</span>
      </div>
      <p class="tips-counter" id="tipsCounter"></p>
      <p class="loading-progress" id="loadingProgress">æº–å‚™ã—ã¦ã„ã¾ã™...</p>
      <div class="loading-bar-wrap">
        <div class="loading-bar"></div>
      </div>
    </div>
    
    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div id="gameScreen" style="display: none;">
      <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
      <div class="game-header">
        <div class="game-header-top">
          <div>
            <div class="timer">â±ï¸ <span id="timeRemaining">60</span>ç§’</div>
            <div class="stats">ã‚¯ãƒªã‚¢: <span id="clearedCount">0</span>å• ï¼ é€Ÿåº¦: <span id="speedDisplay">0.0</span> æ–‡å­—/ç§’</div>
          </div>
          <div style="text-align:right;">
            <div class="score">ğŸ† <span id="currentScore">0</span>ç‚¹ <span id="comboDisplay" style="display:none;"></span></div>
            <div class="stats">å˜èªæ®‹ã‚Š: <span id="wordTimeDisplay">-</span>ç§’</div>
          </div>
        </div>
        <!-- å…¨ä½“ã‚¿ã‚¤ãƒãƒ¼ãƒãƒ¼ -->
        <div class="total-timer-bar-wrap" title="å…¨ä½“æ®‹ã‚Šæ™‚é–“">
          <div class="total-timer-bar" id="totalTimerBar"></div>
        </div>
      </div>
      
      <!-- ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆç”»é¢å…¨ä½“ï¼‰ -->
      <div id="countdownOverlay" class="countdown-overlay" style="display: none;"></div>

      <!-- åˆå›ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
      <div id="tutorialOverlay" class="tutorial-overlay" style="display:none;">
        <div class="tutorial-box">
          <div class="tutorial-icon">ğŸ¤¿</div>
          <div class="tutorial-title">ãƒ—ãƒ¬ã‚¤å‰ã®ãƒã‚§ãƒƒã‚¯</div>
          <ul class="tutorial-tips">
            <li><span class="ti">ğŸ“·</span><span>ã‚«ãƒ¡ãƒ©ã‹ã‚‰ <strong>50ã€œ80cm</strong> ã»ã©é›¢ã‚Œã¦åº§ã‚Šã¾ã—ã‚‡ã†ã€‚è¿‘ã™ãã‚‹ã¨æ‰‹å…¨ä½“ãŒæ˜ ã‚Šã¾ã›ã‚“ã€‚</span></li>
            <li><span class="ti">ğŸ’ª</span><span>æ‰‹ã‚’æŒ™ã’ãŸã¨ã <strong>è‚˜ã¾ã§æ˜ ã‚‹</strong> ä½ç½®ãŒç†æƒ³ã€‚èªè­˜ç²¾åº¦ãŒå¤§ããä¸ŠãŒã‚Šã¾ã™ã€‚</span></li>
            <li><span class="ti">ğŸ’¡</span><span>æ‰‹ã®èƒŒæ™¯ã¯ <strong>æ˜ã‚‹ãã‚·ãƒ³ãƒ—ãƒ«</strong> ãªã»ã©èª­ã¿å–ã‚Šã‚„ã™ããªã‚Šã¾ã™ã€‚</span></li>
            <li><span class="ti">ğŸ–ï¸</span><span>æŒ‡æ–‡å­—ã¯ã‚«ãƒ¡ãƒ©ã«å¯¾ã—ã¦ <strong>æ­£é¢ã‹ã‚‰</strong> è¡¨ç¾ã—ã¦ãã ã•ã„ã€‚</span></li>
          </ul>
          <button class="tutorial-ok-btn" id="tutorialOkBtn">OK é–‹å§‹ã™ã‚‹!</button>
          <span class="tutorial-skip" id="tutorialSkipBtn">OK é–‹å§‹ã™ã‚‹!(æ¬¡å›ã‹ã‚‰è¡¨ç¤ºã—ãªã„)</span>
        </div>
      </div>
      
      <!-- å•é¡Œè¡¨ç¤º -->
      <div class="word-display">
        <canvas id="seaCanvas"></canvas>
        <div class="depth-meter" id="depthMeter">â–¼ 0 m</div>
        <div class="current-word" id="wordDisplay"></div>
        <div class="hiragana-display" id="hiraganaDisplay"></div>
      </div>
      <!-- å˜èªã‚¿ã‚¤ãƒãƒ¼ãƒãƒ¼ï¼ˆå•é¡Œè¡¨ç¤ºç›´ä¸‹ï¼‰ -->
      <div class="word-timer-bar-wrap" title="å˜èªæ®‹ã‚Šæ™‚é–“">
        <div class="word-timer-bar" id="wordTimerBar"></div>
        <div class="combo-marker" id="comboMarker"></div>
      </div>
      
      <!-- ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ -->
      <div class="game-main">
        <div class="camera-area">
          <video id="video" playsinline autoplay muted></video>
          <canvas id="canvas"></canvas>
        </div>
        
        <div class="recognition-area">
          <div class="recognition-result">
            <div class="recognized-char" id="recognizedChar">-</div>
            <div class="confidence" id="confidenceDisplay">-</div>
          </div>
          
          <div class="status-box" id="statusBox">
            æ‰‹ã‚’ã‚«ãƒ¡ãƒ©ã«æ˜ ã—ã¦ãã ã•ã„
          </div>
          <button class="abort-btn" id="abortBtn">â¹ ä¸­æ–­ã™ã‚‹</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- çµæœç”»é¢ -->
  <div class="result-screen" id="resultScreen">
    <div class="result-content">
      <h2 class="result-title">ğŸ‰ ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼</h2>
      
      <div class="result-stats">
        <div class="stat-item">
          <div class="stat-label">ã‚¹ã‚³ã‚¢</div>
          <div class="stat-value" id="finalScore">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">ã‚¯ãƒªã‚¢æ•°</div>
          <div class="stat-value" id="finalCleared">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">ç·æ–‡å­—æ•°</div>
          <div class="stat-value" id="finalChars">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">å¹³å‡é€Ÿåº¦</div>
          <div class="stat-value" id="finalSpeed">0.0</div>
        </div>
      </div>
      
      <div class="title-display">
        <div class="title-emoji" id="titleEmoji">â­</div>
        <div class="title-text" id="titleText">åˆå¿ƒè€…</div>
      </div>
      
      <div class="stage-result" id="stageResult">
        <div class="stage-result-icon" id="stageResultIcon">ğŸ–ï¸</div>
        <div class="stage-result-info">
          <div class="stage-result-name" id="stageResultName">æµ…ç€¬</div>
          <div class="stage-result-depth" id="stageResultDepth">â–¼ 0m</div>
        </div>
        <div class="stage-result-comment" id="stageResultComment">ã¾ã ã¾ã é™¸ã«è¿‘ã„å ´æ‰€ã€‚ã“ã‚Œã‹ã‚‰æ·±æµ·ã¸å‘ã‹ãŠã†ï¼</div>
      </div>
      
      <div class="high-score-notice" id="highScoreNotice" style="display: none;">
        âœ¨ ãƒã‚¤ã‚¹ã‚³ã‚¢æ›´æ–°ï¼
      </div>
      
      <div class="result-actions">
        <button class="result-btn retry-btn" onclick="retry()">ã‚‚ã†ä¸€åº¦</button>
        <button class="result-btn menu-btn" onclick="backToMenu()">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸</button>
      </div>

      <div class="share-btns">
        <button class="share-btn share-btn-x" onclick="shareToX()">
          <svg width="14" height="14" viewBox="0 0 1200 1227" fill="currentColor"><path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.163 519.284ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.828Z"/></svg>
          ã§ã‚·ã‚§ã‚¢
        </button>
        <button class="share-btn share-btn-line" onclick="shareToLINE()">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.627-.63h2.386c.349 0 .63.285.63.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.627-.63.349 0 .631.285.631.63v4.771zm-2.466.629H4.917c-.345 0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348 0 .63.285.63.63v4.141h1.756c.348 0 .629.283.629.63 0 .344-.281.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943 0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"/></svg>
          ã§ã‚·ã‚§ã‚¢
        </button>
      </div>
    </div>
  </div>
  
  <footer class="site-footer">
    <div style="margin-bottom: 8px; text-align: center;">
      <a href="about_yubimoji.html" style="margin: 0 12px; color: #0288d1; text-decoration: none; font-size: 13px; transition: color 0.2s;">æŒ‡æ–‡å­—ã¨ã¯ï¼Ÿ</a>
      <span style="color: rgba(2,136,209,0.3);">|</span>
      <a href="about_signdiver.html" style="margin: 0 12px; color: #0288d1; text-decoration: none; font-size: 13px; transition: color 0.2s;">Sign Diverã¨ã¯ï¼Ÿ</a>
      <span style="color: rgba(2,136,209,0.3);">|</span>
      <a href="terms.html" style="margin: 0 12px; color: #0288d1; text-decoration: none; font-size: 13px; transition: color 0.2s;">åˆ©ç”¨è¦ç´„</a>
      <span style="color: rgba(2,136,209,0.3);">|</span>
      <a href="privacy.html" style="margin: 0 12px; color: #0288d1; text-decoration: none; font-size: 13px; transition: color 0.2s;">ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼</a>
    </div>
    <a href="https://www.youtube.com/@Katsuo_Shuwa_Doga" target="_blank" rel="noopener noreferrer">
      <span class="footer-icon">â–¶</span>
      <span class="footer-name">@KatsuoShuwaDoga</span>
    </a>
  </footer>
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
  <script type="module">
    import { HandLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21/vision_bundle.mjs';
    
    const WASM_BASE = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21/wasm";
    const MODEL_URL = "./mediapipe/hand_landmarker.task";

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const PERF = {
      marks: {},
      mark(name) {
        this.marks[name] = performance.now();
        console.log(`[PERF] ${name}: ${this.marks[name].toFixed(0)}ms (page open)`);
      },
      elapsed(from, to) {
        const ms = (this.marks[to] - this.marks[from]);
        console.log(`[PERF] ${from} â†’ ${to}: ${ms.toFixed(0)}ms`);
        return ms;
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ãƒšãƒ¼ã‚¸ã‚’é–‹ã„ãŸç¬é–“ã‹ã‚‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ãƒ­ãƒ¼ãƒ‰é–‹å§‹
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let bgLoadPromise = null;
    let model = null, labelMap = null, landmarker = null, stream = null;

    (function startBackgroundLoad() {
      PERF.mark('bg_load_start');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ææ¡ˆ1: TFJSã¨MediaPipeã‚’ä¸¦åˆ—ãƒ­ãƒ¼ãƒ‰
      //   ç›´åˆ—: TFJS(~1.5s) â†’ MediaPipe(~9s) = ~10.5s
      //   ä¸¦åˆ—: max(TFJS, MediaPipe)          = ~9s
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // â”€â”€ TFJS: ãƒ¢ãƒ‡ãƒ« â†’ ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ— â†’ ãƒ©ãƒ™ãƒ«ãƒãƒƒãƒ— â”€â”€
      const tfPromise = (async () => {
        updateLoadingProgress('AIãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');
        PERF.mark('tf_model_fetch_start');
        model = await tf.loadGraphModel('./tfjs_model_official/model.json');
        PERF.mark('tf_model_ready');
        PERF.elapsed('tf_model_fetch_start', 'tf_model_ready');

        PERF.mark('warmup_start');
        const warmupInput = tf.zeros([1, 15, 63]);
        const warmupOutput = await model.executeAsync(warmupInput);
        if (Array.isArray(warmupOutput)) warmupOutput.forEach(t => t.dispose());
        else warmupOutput.dispose();
        warmupInput.dispose();
        PERF.mark('warmup_done');
        PERF.elapsed('warmup_start', 'warmup_done');

        const labelResponse = await fetch('./tfjs_model_official/label_map_unified.json');
        labelMap = await labelResponse.json();
        PERF.mark('labelmap_ready');
      })();

      // â”€â”€ MediaPipe: TFJSã¨ä¸¦åˆ—ã§é–‹å§‹ â”€â”€
      const mediapipePromise = (async () => {
        updateLoadingProgress('æ‰‹ã®èªè­˜ã‚¨ãƒ³ã‚¸ãƒ³ã‚’æº–å‚™ã—ã¦ã„ã¾ã™...');
        PERF.mark('mediapipe_start');
        const fileset = await FilesetResolver.forVisionTasks(WASM_BASE);
        PERF.mark('wasm_compile_done');
        PERF.elapsed('mediapipe_start', 'wasm_compile_done');

        // ãƒ¢ãƒ‡ãƒ«DLã¨åˆæœŸåŒ–ã‚’åˆ†é›¢ã—ã¦è¨ˆæ¸¬
        PERF.mark('task_model_download_start');
        const modelResponse = await fetch(MODEL_URL);
        const modelBuffer = await modelResponse.arrayBuffer();
        PERF.mark('task_model_download_done');
        PERF.elapsed('task_model_download_start', 'task_model_download_done');

        PERF.mark('task_init_start');
        landmarker = await HandLandmarker.createFromOptions(fileset, {
          baseOptions: { modelAssetPath: MODEL_URL },
          runningMode: "VIDEO",
          numHands: 1
        });
        PERF.mark('mediapipe_ready');
        PERF.elapsed('task_init_start', 'mediapipe_ready');
        PERF.elapsed('mediapipe_start', 'mediapipe_ready');
      })();

      // â”€â”€ ä¸¡æ–¹å®Œäº†ã‚’å¾…ã¤ â”€â”€
      bgLoadPromise = Promise.all([tfPromise, mediapipePromise])
        .then(() => {
          PERF.mark('all_ready');
          PERF.elapsed('bg_load_start', 'all_ready');
          console.log('[PERF] ä¸¦åˆ—ãƒ­ãƒ¼ãƒ‰å®Œäº† âœ…');
        })
        .catch(e => {
          console.error('[PERF] Background load error:', e);
          throw e;
        });
    })();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ãƒ†ã‚£ãƒƒãƒ—ã‚¹ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let tipsTimer = null;

    async function startTipsRotation() {
      try {
        const res = await fetch('./data/tips.json');
        const tips = await res.json();
        if (!tips.length) return;

        let idx = Math.floor(Math.random() * tips.length);

        function showTip(tip, index) {
          const card = document.getElementById('tipsCard');
          const emoji = document.getElementById('tipsEmoji');
          const text = document.getElementById('tipsText');
          const counter = document.getElementById('tipsCounter');
          if (!card) return;
          card.style.opacity = '0';
          setTimeout(() => {
            emoji.textContent = tip.emoji;
            text.textContent = tip.text;
            counter.textContent = `${index + 1} / ${tips.length}`;
            card.style.opacity = '1';
          }, 400);
        }

        // æœ€åˆã®1æšã‚’å³è¡¨ç¤º
        showTip(tips[idx], idx);

        // 4ç§’ã”ã¨ã«æ¬¡ã®ãƒ†ã‚£ãƒƒãƒ—ã‚¹ã¸
        tipsTimer = setInterval(() => {
          idx = (idx + 1) % tips.length;
          showTip(tips[idx], idx);
        }, 4000);

      } catch(e) {
        // tips.jsonãŒèª­ã‚ãªãã¦ã‚‚ç„¡è¦–ï¼ˆãƒ­ãƒ¼ãƒ‰ã«ã¯å½±éŸ¿ã—ãªã„ï¼‰
      }
    }

    function stopTipsRotation() {
      if (tipsTimer) {
        clearInterval(tipsTimer);
        tipsTimer = null;
      }
    }

    // ãƒšãƒ¼ã‚¸ã‚’é–‹ã„ãŸç¬é–“ã‹ã‚‰ãƒ†ã‚£ãƒƒãƒ—ã‚¹é–‹å§‹
    startTipsRotation();

    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—
    const params = new URLSearchParams(window.location.search);
    const difficulty = params.get('difficulty') || 'easy';
    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å„ªå…ˆ â†’ localStorage â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆright
    const selectedHand = params.get('hand') || localStorage.getItem('signDiver_hand') || 'right';
    const timeLimit = parseInt(params.get('time')) || 60;

    // ã‚«ãƒ¡ãƒ©æ˜ åƒè¡¨ç¤ºè¨­å®šï¼ˆlocalStorageï¼‰
    const showCamera = localStorage.getItem('signDiver_showCamera') !== 'false';
    if (!showCamera) {
      document.querySelectorAll('.camera-area').forEach(el => el.classList.add('hidden'));
    }

    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼ˆmodel/labelMap/landmarker/streamã¯ä¸Šéƒ¨ã§å®£è¨€æ¸ˆã¿ï¼‰
    let rafId = null;
    
    let wordList = [];
    let remainingWords = [];
    let currentWord = null;
    let currentIndex = 0;
    
    let isPlaying = false;
    let timeRemaining = timeLimit;
    let score = 0;
    let clearedCount = 0;
    let totalChars = 0;
    let totalTime = 0;
    let charStartTime = 0;
    
    let timerInterval = null;
    
    // å˜èªæ¯ã®ã‚¿ã‚¤ãƒãƒ¼
    let wordTimeRemaining = 0;      // ç¾åœ¨ã®å˜èªã®æ®‹ã‚Šæ™‚é–“
    let wordTimeLimit = 0;          // ç¾åœ¨ã®å˜èªã®åˆ¶é™æ™‚é–“
    let wordTimerInterval = null;   // å˜èªã‚¿ã‚¤ãƒãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«
    let missedWords = 0;            // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸå˜èªæ•°
    
    // ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ 
    let combo = 0;                  // ç¾åœ¨ã®ã‚³ãƒ³ãƒœæ•°ï¼ˆè¡¨ç¤ºç”¨ãƒ»é€”åˆ‡ã‚Œã‚‹ã¾ã§å¢—åŠ ï¼‰
    let maxCombo = 0;               // æœ€å¤§ã‚³ãƒ³ãƒœæ•°
    let bonusCombo = 0;             // ãƒœãƒ¼ãƒŠã‚¹åˆ¤å®šç”¨ã‚³ãƒ³ãƒœï¼ˆ10é”æˆã§ãƒªã‚»ãƒƒãƒˆï¼‰
    let comboThreshold = 0;         // ã‚³ãƒ³ãƒœåˆ¤å®šã®é–¾å€¤ï¼ˆåˆ¶é™æ™‚é–“ã®50%ï¼‰
    
    // è‹±èªãƒ©ãƒ™ãƒ«ã‹ã‚‰æ—¥æœ¬èªã¸ã®å¤‰æ›ãƒãƒƒãƒ—ï¼ˆå®Œå…¨ç‰ˆï¼‰
    const romajiToHiragana = {
      // æ¸…éŸ³
      "a": "ã‚", "i": "ã„", "u": "ã†", "e": "ãˆ", "o": "ãŠ",
      "ka": "ã‹", "ki": "ã", "ku": "ã", "ke": "ã‘", "ko": "ã“",
      "sa": "ã•", "si": "ã—", "shi": "ã—", "su": "ã™", "se": "ã›", "so": "ã",
      "ta": "ãŸ", "ti": "ã¡", "chi": "ã¡", "tu": "ã¤", "tsu": "ã¤", "te": "ã¦", "to": "ã¨",
      "na": "ãª", "ni": "ã«", "nu": "ã¬", "ne": "ã­", "no": "ã®",
      "ha": "ã¯", "hi": "ã²", "hu": "ãµ", "fu": "ãµ", "he": "ã¸", "ho": "ã»",
      "ma": "ã¾", "mi": "ã¿", "mu": "ã‚€", "me": "ã‚", "mo": "ã‚‚",
      "ya": "ã‚„", "yu": "ã‚†", "yo": "ã‚ˆ",
      "ra": "ã‚‰", "ri": "ã‚Š", "ru": "ã‚‹", "re": "ã‚Œ", "ro": "ã‚",
      "wa": "ã‚", "wo": "ã‚’", "n": "ã‚“", "nn": "ã‚“",
      
      // æ¿éŸ³
      "ga": "ãŒ", "gi": "ã", "gu": "ã", "ge": "ã’", "go": "ã”",
      "za": "ã–", "zi": "ã˜", "ji": "ã˜", "zu": "ãš", "ze": "ãœ", "zo": "ã",
      "da": "ã ", "di": "ã¢", "du": "ã¥", "de": "ã§", "do": "ã©",
      "ba": "ã°", "bi": "ã³", "bu": "ã¶", "be": "ã¹", "bo": "ã¼",
      
      // åŠæ¿éŸ³
      "pa": "ã±", "pi": "ã´", "pu": "ã·", "pe": "ãº", "po": "ã½",
      
      // æ‹—éŸ³
      "kya": "ãã‚ƒ", "kyu": "ãã‚…", "kyo": "ãã‚‡",
      "sha": "ã—ã‚ƒ", "shu": "ã—ã‚…", "sho": "ã—ã‚‡",
      "cha": "ã¡ã‚ƒ", "chu": "ã¡ã‚…", "cho": "ã¡ã‚‡",
      "nya": "ã«ã‚ƒ", "nyu": "ã«ã‚…", "nyo": "ã«ã‚‡",
      "hya": "ã²ã‚ƒ", "hyu": "ã²ã‚…", "hyo": "ã²ã‚‡",
      "mya": "ã¿ã‚ƒ", "myu": "ã¿ã‚…", "myo": "ã¿ã‚‡",
      "rya": "ã‚Šã‚ƒ", "ryu": "ã‚Šã‚…", "ryo": "ã‚Šã‚‡",
      "gya": "ãã‚ƒ", "gyu": "ãã‚…", "gyo": "ãã‚‡",
      "ja": "ã˜ã‚ƒ", "ju": "ã˜ã‚…", "jo": "ã˜ã‚‡",
      "bya": "ã³ã‚ƒ", "byu": "ã³ã‚…", "byo": "ã³ã‚‡",
      "pya": "ã´ã‚ƒ", "pyu": "ã´ã‚…", "pyo": "ã´ã‚‡",
      
      // å°æ–‡å­—ã²ã‚‰ãŒãªå˜ä½“ï¼ˆxè¡¨è¨˜ãƒ»lè¡¨è¨˜ã©ã¡ã‚‰ã‚‚å¯¾å¿œï¼‰
      // ãƒ¢ãƒ‡ãƒ«ãŒã€Œã‚‡ã€ã‚’xyoã€ã€Œã‚ƒã€ã‚’xya ãªã©ã¨å‡ºåŠ›ã™ã‚‹ã‚±ãƒ¼ã‚¹ã«å¯¾å¿œ
      "xa": "ã",  "xi": "ãƒ",  "xu": "ã…",  "xe": "ã‡",  "xo": "ã‰",
      "la": "ã",  "li": "ãƒ",  "lu": "ã…",  "le": "ã‡",  "lo": "ã‰",
      "xya": "ã‚ƒ", "xyu": "ã‚…", "xyo": "ã‚‡",
      "lya": "ã‚ƒ", "lyu": "ã‚…", "lyo": "ã‚‡",
      "xtu": "ã£", "xtsu": "ã£",
      "ltu": "ã£", "ltsu": "ã£",
      "xwa": "ã‚", "lwa": "ã‚",
      
      // é•·éŸ³è¨˜å·ï¼ˆä¼¸ã°ã—æ£’ï¼‰
      "bar": "ãƒ¼"
    };
    
    // ã‚¨ã‚¤ãƒªã‚¢ã‚¹å®šç¾©
    const aliases = {
      "ã‚’": ["ãŠ", "ã‰"],  // ã‚’ã¯ã€ŒãŠã€ã€Œã‰ã€ã§ã‚‚OK
      "ãŠ": ["ã‚’", "ã‰"],  // ãŠã¯ã€Œã‚’ã€ã€Œã‰ã€ã§ã‚‚OK
      "ã‰": ["ã‚’", "ãŠ"]   // ã‰ã¯ã€Œã‚’ã€ã€ŒãŠã€ã§ã‚‚OK
    };
    
    // æ¿éŸ³â†’æ¸…éŸ³ã®å¤‰æ›ãƒãƒƒãƒ—ï¼ˆè£œæ­£ç”¨ï¼‰
    const dakuonToSeion = {
      // æ¿éŸ³â†’æ¸…éŸ³
      "ãŒ": "ã‹", "ã": "ã", "ã": "ã", "ã’": "ã‘", "ã”": "ã“",
      "ã–": "ã•", "ã˜": "ã—", "ãš": "ã™", "ãœ": "ã›", "ã": "ã",
      "ã ": "ãŸ", "ã¢": "ã¡", "ã¥": "ã¤", "ã§": "ã¦", "ã©": "ã¨",
      "ã°": "ã¯", "ã³": "ã²", "ã¶": "ãµ", "ã¹": "ã¸", "ã¼": "ã»",
      
      // åŠæ¿éŸ³â†’æ¸…éŸ³
      "ã±": "ã¯", "ã´": "ã²", "ã·": "ãµ", "ãº": "ã¸", "ã½": "ã»"
    };
    
    // å°ã•ã„æ–‡å­—â†’å¤§ãã„æ–‡å­—ã®å¤‰æ›ãƒãƒƒãƒ—ï¼ˆè£œæ­£ç”¨ï¼‰
    const komojiToOmoji = {
      // ã‚è¡Œ
      "ã": "ã‚", "ãƒ": "ã„", "ã…": "ã†", "ã‡": "ãˆ", "ã‰": "ãŠ",
      
      // ã‚„è¡Œ
      "ã‚ƒ": "ã‚„", "ã‚…": "ã‚†", "ã‚‡": "ã‚ˆ",
      
      // ã‚è¡Œ
      "ã‚": "ã‚",
      
      // ã¤ï¼ˆä¿ƒéŸ³ï¼‰
      "ã£": "ã¤"
    };
    
    // ========================================
    // æ–‡å­—ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆç›¸äº’èªè­˜ï¼‰
    // ========================================
    // åŒã˜ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®æ–‡å­—ã¯äº’ã„ã«èªè­˜å¯èƒ½
    // ä¾‹: ["ã¯", "ã°", "ã±"] â†’ ã¯ãƒ»ã°ãƒ»ã±ã‚’ç›¸äº’ã«èªè­˜
    // 
    // æ³¨æ„: å°ã•ã„æ–‡å­—ï¼ˆããƒã…ã‡ã‰ã‚ƒã‚…ã‚‡ã‚ã£ï¼‰ã¯ä¸€æ–¹å‘è£œæ­£ï¼ˆkomojiToOmojiï¼‰ã§å‡¦ç†
    //      ç›¸äº’èªè­˜ã§ã¯ãªã„ãŸã‚ã€charGroupsã«ã¯å«ã‚ãªã„
    // ========================================
    const charGroups = [
      // ã‚°ãƒ«ãƒ¼ãƒ—1: ã¯ ã¨ ãã®æ¿éŸ³ãƒ»åŠæ¿éŸ³ï¼ˆMediaPipeã§èªè­˜ã—ã¥ã‚‰ã„ãŸã‚ç›¸äº’èªè­˜ï¼‰
      ["ã¯", "ã°", "ã±"],
    ];
    
    // æ–‡å­—ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
    function isInSameGroup(char1, char2) {
      for (const group of charGroups) {
        if (group.includes(char1) && group.includes(char2)) {
          return true;
        }
      }
      return false;
    }
    
    // ========================================
    // æŒ‡æ–‡å­—ã®ã€Œå½¢ã€ã¨ã—ã¦åŒä¸€ã‹ã‚’åˆ¤å®šã™ã‚‹æ­£è¦åŒ–é–¢æ•°
    // æ¿ç‚¹ãƒ»åŠæ¿ç‚¹ã¯æ¸…éŸ³ã¨åŒã˜å½¢ãªã®ã§ã€æ¸…éŸ³ã«å¤‰æ›ã—ã¦æ¯”è¼ƒã™ã‚‹
    // å°ã•ã„æ–‡å­—ã‚‚å¤§ãã„æ–‡å­—ã¨åŒã˜å½¢ã¨ã—ã¦æ‰±ã†
    // charGroupsã§åŒã‚°ãƒ«ãƒ¼ãƒ—ã®å ´åˆã¯ã‚°ãƒ«ãƒ¼ãƒ—ä»£è¡¨(å…ˆé ­)ã«çµ±ä¸€
    // ========================================
    function toSignForm(char) {
      // Step1: æ¿éŸ³ãƒ»åŠæ¿éŸ³ â†’ æ¸…éŸ³
      let normalized = dakuonToSeion[char] || char;
      
      // Step2: å°ã•ã„æ–‡å­— â†’ å¤§ãã„æ–‡å­—
      normalized = komojiToOmoji[normalized] || normalized;
      
      // Step3: charGroupsã§åŒã‚°ãƒ«ãƒ¼ãƒ—ãªã‚‰å…ˆé ­æ–‡å­—ã«çµ±ä¸€
      for (const group of charGroups) {
        if (group.includes(normalized)) {
          return group[0];
        }
      }
      
      return normalized;
    }
    
    // èªè­˜çµæœã‚’æ—¥æœ¬èªã«å¤‰æ›
    function convertToHiragana(sign) {
      // ã™ã§ã«æ—¥æœ¬èªã®å ´åˆã¯ãã®ã¾ã¾
      if (romajiToHiragana[sign]) {
        return romajiToHiragana[sign];
      }
      return sign;
    }
    
    // åˆæœŸåŒ–
    async function init() {
      try {
        // â‘  å˜èªãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ï¼ˆãƒ­ãƒ¼ãƒ‰ç”»é¢ã®ã¾ã¾ï¼‰
        updateLoadingProgress('å˜èªãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');
        await loadWords();

        const isFirstLoad = !localStorage.getItem('signDiver_loaded');
        if (isFirstLoad) localStorage.setItem('signDiver_loaded', '1');

        PERF.mark('start_btn_pressed');

        // â‘¡ é‡ã„åˆæœŸåŒ–ï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ­ãƒ¼ãƒ‰ãŒçµ‚ã‚ã£ã¦ã„ã‚Œã°å³é€šéï¼‰
        //    ã“ã®é–“ã‚‚loadingScreenã‚’è¡¨ç¤ºã—ãŸã¾ã¾å¾…æ©Ÿ
        PERF.mark('parallel_start');
        await initHeavy();
        PERF.mark('parallel_done');
        PERF.elapsed('start_btn_pressed', 'parallel_done');

        // â‘¢ ãƒ­ãƒ¼ãƒ‰å®Œäº† â†’ gameScreenã‚’è¡¨ç¤ºã™ã‚‹ã¨åŒæ™‚ã«ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚’å³è¡¨ç¤º
        //    ã“ã‚Œã§loadingScreen â†’ ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ãŒã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã«è¦‹ãˆã‚‹
        stopTipsRotation();
        document.getElementById('loadingScreen').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';
        requestAnimationFrame(() => { SEA.resize(); });

        // åˆå›è¨ªå•ãƒã‚§ãƒƒã‚¯ â†’ ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«è¡¨ç¤º
        if (!localStorage.getItem('signDiver_seenTutorial')) {
          await showTutorial();
        }

        // â‘£ ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ˆstartGameå†…ã§ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚’è¡¨ç¤ºï¼‰
        startGame(isFirstLoad);

      } catch (error) {
        console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        alert('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
      }
    }

    // é‡ã„åˆæœŸåŒ–å‡¦ç†ï¼šãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ­ãƒ¼ãƒ‰ã¨ã‚«ãƒ¡ãƒ©ã‚’ä¸¦åˆ—ã§å¾…ã¤
    // ==========================================
    // ã‚«ãƒ¡ãƒ©èµ·å‹•ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ»è¤‡æ•°ã‚«ãƒ¡ãƒ©å¯¾å¿œï¼‰
    // ==========================================
    function showCameraError(type) {
      const modal = document.getElementById('cameraErrorModal');
      const icon  = document.getElementById('camErrIcon');
      const title = document.getElementById('camErrTitle');
      const body  = document.getElementById('camErrBody');

      if (type === 'busy') {
        icon.textContent  = 'ğŸ”’';
        title.textContent = 'ã‚«ãƒ¡ãƒ©ãŒä½¿ç”¨ä¸­ã§ã™';
        body.innerHTML    =
          'Zoomã‚„Teamsã€ä»–ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚¿ãƒ–ãªã©ã€åˆ¥ã®ã‚¢ãƒ—ãƒªãŒã‚«ãƒ¡ãƒ©ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚<br><br>' +
          '<b>å¯¾å‡¦æ–¹æ³•:</b><br>' +
          'â‘  ä»–ã®ã‚¢ãƒ—ãƒªãƒ»ã‚¿ãƒ–ã§ã‚«ãƒ¡ãƒ©ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã¯çµ‚äº†ã—ã¦ãã ã•ã„<br>' +
          'â‘¡ ãã®å¾Œã€Œå†è©¦è¡Œã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„';
      } else if (type === 'denied') {
        icon.textContent  = 'ğŸš«';
        title.textContent = 'ã‚«ãƒ¡ãƒ©ã®ä½¿ç”¨ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“';
        body.innerHTML    =
          'ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ã¾ã™ã€‚<br><br>' +
          '<b>è¨±å¯ã®æ–¹æ³•:</b><br>' +
          'Â· <b>Chrome</b>: ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼å·¦ã® ğŸ”’ â†’ ã€Œã‚«ãƒ¡ãƒ©ã€â†’ã€Œè¨±å¯ã€<br>' +
          'Â· <b>Edge</b>: ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼å·¦ã® ğŸ”’ â†’ ã€Œã‚«ãƒ¡ãƒ©ã€â†’ã€Œè¨±å¯ã€<br>' +
          'Â· <b>Safari</b>: è¨­å®š â†’ Safari â†’ ã‚«ãƒ¡ãƒ© â†’ è¨±å¯<br><br>' +
          'è¨±å¯å¾Œã«ã€Œå†è©¦è¡Œã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚';
      } else {
        icon.textContent  = 'âŒ';
        title.textContent = 'ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
        body.innerHTML    =
          'ã‚«ãƒ¡ãƒ©ãƒ‡ãƒã‚¤ã‚¹ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚<br><br>' +
          'Â· ã‚«ãƒ¡ãƒ©ãŒæ­£ã—ãæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„<br>' +
          'Â· å†…è”µã‚«ãƒ¡ãƒ©ãŒã‚ã‚‹å ´åˆã¯ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„';
      }

      modal.classList.add('show');
      return new Promise(resolve => {
        document.getElementById('camErrRetry').onclick = () => { modal.classList.remove('show'); resolve('retry'); };
        document.getElementById('camErrSkip').onclick  = () => { modal.classList.remove('show'); resolve('skip'); };
      });
    }

    function showCameraSelect(devices) {
      const modal = document.getElementById('cameraSelectModal');
      const list  = document.getElementById('camSelectList');
      list.innerHTML = '';

      devices.forEach((device, i) => {
        const btn = document.createElement('button');
        btn.className = 'cam-select-item' + (i === 0 ? ' recommended' : '');
        btn.textContent = device.label || `ã‚«ãƒ¡ãƒ© ${i + 1}`;
        list.appendChild(btn);
      });
      modal.classList.add('show');
      return new Promise(resolve => {
        list.querySelectorAll('.cam-select-item').forEach((btn, i) => {
          btn.onclick = () => { modal.classList.remove('show'); resolve(devices[i].deviceId); };
        });
        document.getElementById('camSelectSkip').onclick = () => { modal.classList.remove('show'); resolve(null); };
      });
    }

    async function startCameraWithHandling(videoEl) {
      while (true) {
        try {
          const devices = (await navigator.mediaDevices.enumerateDevices())
            .filter(d => d.kind === 'videoinput');

          let deviceId = null;
          if (devices.length > 1 && devices[0].label) {
            deviceId = await showCameraSelect(devices);
            if (deviceId === null) return null;
          }

          const constraints = {
            video: deviceId
              ? { deviceId: { exact: deviceId } }
              : { facingMode: 'user', width: 640, height: 480 },
            audio: false,
          };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          videoEl.srcObject = stream;
          return stream;

        } catch (err) {
          let errorType = 'unknown';
          if (err.name === 'NotReadableError' || err.name === 'AbortError') errorType = 'busy';
          else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') errorType = 'denied';
          else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') errorType = 'notfound';
          const action = await showCameraError(errorType);
          if (action === 'skip') return null;
        }
      }
    }

    async function initHeavy() {
      PERF.mark('init_heavy_start');

      // ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚’bgLoadPromiseã¨ä¸¦åˆ—ã§é–‹å§‹
      // ï¼ˆbgLoadPromiseã¯ã™ã§ã«ãƒšãƒ¼ã‚¸é–‹æ™‚ã‹ã‚‰èµ°ã£ã¦ã„ã‚‹ãŸã‚å®Ÿè³ªçš„ã«ä¸¦åˆ—ï¼‰
      updateLoadingProgress('ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ã—ã¦ã„ã¾ã™...');
      PERF.mark('camera_start');
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');

      // bgLoadPromiseã¨ä¸¦åˆ—ã§ã‚«ãƒ¡ãƒ©èµ·å‹•ï¼ˆè¤‡æ•°ã‚«ãƒ¡ãƒ©å¯¾å¿œÂ·ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
      const waitStart = performance.now();
      const [s] = await Promise.all([
        startCameraWithHandling(video),
        bgLoadPromise,
      ]);
      stream = s;
      const waited = (performance.now() - waitStart).toFixed(0);

      PERF.mark('camera_ready');
      PERF.elapsed('camera_start', 'camera_ready');
      if (Number(waited) < 50) {
        console.log(`[PERF] bg_load: already done when start pressed âœ…`);
      } else {
        console.log(`[PERF] bg_load: had to wait ${waited}ms after start pressed âš ï¸`);
      }

      if (!stream) {
        // ã‚«ãƒ¡ãƒ©ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ï¼‰
        window.location.href = './index.html';
        return;
      }

      await new Promise(resolve => { video.onloadedmetadata = resolve; });
      await video.play();
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;
      PERF.mark('bg_load_awaited');
      PERF.elapsed('init_heavy_start', 'bg_load_awaited');
    }
    
    function updateLoadingProgress(text) {
      document.getElementById('loadingProgress').textContent = text;
    }
    
    // å˜èªãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    async function loadWords() {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–: ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’URLã«ä»˜åŠ ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚¤ãƒ‘ã‚¹
      const cacheBuster = `?v=${Date.now()}`;
      const response = await fetch(`./data/words_${difficulty}.txt${cacheBuster}`);
      const text = await response.text();
      
      wordList = text
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0 && line.includes('|'))
        .map(line => {
          const [display, hiragana] = line.split('|');
          return {
            display: display.trim(),
            hiragana: hiragana.trim()
          };
        });
      
      remainingWords = [...wordList];

    }
    
    // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤ºï¼ˆseconds: ã‚«ã‚¦ãƒ³ãƒˆé–‹å§‹ç§’æ•°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ3ï¼‰
    async function showCountdown(seconds = 3) {
      const overlay = document.getElementById('countdownOverlay');
      
      // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æœ€åˆã«1å›ã ã‘è¡¨ç¤ºï¼ˆä»¥é™ã¯æ¶ˆã•ãªã„ï¼‰
      overlay.style.display = 'flex';
      overlay.style.flexDirection = 'column';
      overlay.style.gap = '40px';
      
      // æŒ‡å®šç§’æ•°ã‹ã‚‰ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³
      const counts = [];
      for (let i = seconds; i >= 1; i--) counts.push(String(i));
      counts.push('Start!');
      
      for (let i = 0; i < counts.length; i++) {
        // å¤ã„å†…å®¹ã‚’å‰Šé™¤
        overlay.innerHTML = '';
        
        // æ•°å­—spanã‚’ä½œæˆ
        const span = document.createElement('span');
        span.className = 'countdown-number' + (i === 3 ? ' start' : '');
        span.textContent = counts[i];
        overlay.appendChild(span);
        
        // Start!ä»¥å¤–ã®æ™‚ã¯Escã‚­ãƒ¼ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ã‚’è¡¨ç¤º
        if (i < 3) {
          const guide = document.createElement('div');
          guide.style.fontSize = '16px';
          guide.style.fontWeight = '500';
          guide.style.color = 'rgba(255,255,255,0.5)';
          guide.style.letterSpacing = '1px';
          guide.textContent = 'Escã‚­ãƒ¼ã§ä¸­æ–­';
          overlay.appendChild(guide);
        }
        
        await new Promise(resolve => setTimeout(resolve, i === 3 ? 600 : 900));
      }
      
      // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
      overlay.style.transition = 'opacity 0.3s';
      overlay.style.opacity = '0';
      await new Promise(resolve => setTimeout(resolve, 300));
      overlay.style.display = 'none';
      overlay.style.opacity = '1';
      overlay.style.transition = '';
      overlay.innerHTML = '';
      overlay.style.flexDirection = '';
      overlay.style.gap = '';
    }
    
    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
    function resetGameState() {
      // çµæœç”»é¢ã‚’éè¡¨ç¤º
      document.getElementById('resultScreen').classList.remove('show');
      
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      isPlaying = true;
      timeRemaining = timeLimit;
      score = 0;
      clearedCount = 0;
      totalChars = 0;
      totalTime = 0;
      missedWords = 0;
      combo = 0;
      bonusCombo = 0;
      maxCombo = 0;
      
      // å˜èªãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
      remainingWords = [...wordList];
      currentWord = null;
      
      // UIæ›´æ–°
      document.getElementById('timeRemaining').textContent = timeRemaining;
      document.getElementById('currentScore').textContent = score;
      document.getElementById('clearedCount').textContent = clearedCount;
      document.getElementById('speedDisplay').textContent = '0.0';
      document.getElementById('wordTimeDisplay').textContent = '-';
      updateComboDisplay();
    }
    
    // ã‚²ãƒ¼ãƒ é–‹å§‹
    // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆPromise ã§å¾…æ©Ÿï¼‰
    function showTutorial() {
      return new Promise(resolve => {
        const overlay = document.getElementById('tutorialOverlay');
        overlay.style.display = 'flex';

        // ã€Œæº–å‚™OKã€â†’ æ¬¡å›ã‚‚è¡¨ç¤º
        document.getElementById('tutorialOkBtn').addEventListener('click', () => {
          overlay.style.display = 'none';
          resolve();
        }, { once: true });

        // ã€Œæ¬¡å›ã‹ã‚‰è¡¨ç¤ºã—ãªã„ã€â†’ ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã¦é–‰ã˜ã‚‹
        document.getElementById('tutorialSkipBtn').addEventListener('click', () => {
          localStorage.setItem('signDiver_seenTutorial', '1');
          overlay.style.display = 'none';
          resolve();
        }, { once: true });
      });
    }

    async function startGame(isFirst = false) {
      // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤ºï¼ˆåˆå›ã¯5ç§’ãƒ»2å›ç›®ä»¥é™ã¯3ç§’ï¼‰
      await showCountdown(isFirst ? 5 : 3);
      
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
      resetGameState();
      SEA.renderBg1 = SEA.LEVELS[0].bg1;
      SEA.renderBg2 = SEA.LEVELS[0].bg2;
      SEA.renderRays = SEA.LEVELS[0].rays;
      SEA.updateScore(0);  // æ·±æµ·ã‚’ãƒªã‚»ãƒƒãƒˆ
      
      nextWord();
      startTimer();
      rafId = requestAnimationFrame(loop);
    }
    
    // æ¬¡ã®å•é¡Œï¼ˆå˜èªé€£ç¶šé˜²æ­¢ä»˜ãï¼‰
    function nextWord() {
      // å…¨å•é¡Œä½¿ã„åˆ‡ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
      if (remainingWords.length === 0) {
        remainingWords = [...wordList];
      }
      
      // å‰ã®å˜èªã®æœ€å¾Œã®æ–‡å­—
      const prevLastChar = currentWord ? currentWord.hiragana[currentWord.hiragana.length - 1] : null;
      const prevLastForm = prevLastChar ? toSignForm(prevLastChar) : null;
      
      // å€™è£œã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      let candidates = remainingWords;
      
      if (prevLastForm && remainingWords.length > 1) {
        // æŒ‡æ–‡å­—ã®ã€Œå½¢ã€ãŒåŒã˜ã«ãªã‚‹çµ„ã¿åˆã‚ã›ã‚’é™¤å¤–
        // ä¾‹: ã”(ã“)â†’ã“ã‚ã‚‰ã€ã¯â†’ã°ãªãªã€ã¤â†’ã£ã±ã„ ãªã©
        candidates = remainingWords.filter(word => {
          const firstForm = toSignForm(word.hiragana[0]);
          return firstForm !== prevLastForm;
        });
        
        // ãƒ•ã‚£ãƒ«ã‚¿å¾Œã«å€™è£œãŒãªã„å ´åˆã¯å…¨ä½“ã‹ã‚‰é¸æŠ
        if (candidates.length === 0) {
          candidates = remainingWords;
        }
      }
      
      // ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
      const index = Math.floor(Math.random() * candidates.length);
      const selectedWord = candidates[index];
      
      // remainingWordsã‹ã‚‰å‰Šé™¤
      const originalIndex = remainingWords.indexOf(selectedWord);
      remainingWords.splice(originalIndex, 1);
      
      currentWord = selectedWord;
      currentIndex = 0;
      charStartTime = performance.now();
      
      updateWordDisplay();

      
      if (prevLastChar) {
        const nextFirstChar = currentWord.hiragana[0];
        const nextFirstForm = toSignForm(nextFirstChar);

      }
      
      // å˜èªã‚¿ã‚¤ãƒãƒ¼åˆæœŸåŒ–
      startWordTimer();
    }
    
    // å˜èªè¡¨ç¤ºæ›´æ–°
    function updateWordDisplay() {
      const displayEl = document.getElementById('wordDisplay');
      const hiraganaEl = document.getElementById('hiraganaDisplay');
      const chars = currentWord.display.split('');
      const hiraganaChars = currentWord.hiragana.split('');
      
      // ã²ã‚‰ãŒãªãƒ™ãƒ¼ã‚¹ã®é€²æ—ç‡ï¼ˆ0.0ã€œ1.0ï¼‰
      const hiraganaProgress = hiraganaChars.length > 0 ? currentIndex / hiraganaChars.length : 0;
      
      // æ¼¢å­—è¡¨ç¤ºå´ã®ç¾åœ¨ä½ç½®ã‚’é€²æ—ç‡ã‹ã‚‰è¨ˆç®—
      const displayCurrentIndex = Math.floor(hiraganaProgress * chars.length);
      
      // è¡¨ç¤ºæ–‡å­—ï¼ˆæ¼¢å­—ãªã©ï¼‰- é€²æ—ç‡ãƒ™ãƒ¼ã‚¹ã§è‰²ä»˜ã‘
      displayEl.innerHTML = chars.map((char, i) => {
        let className = 'char';
        if (i < displayCurrentIndex) {
          className += ' completed';
        } else if (i === displayCurrentIndex) {
          className += ' current';
        } else {
          className += ' pending';
        }
        return `<span class="${className}">${char}</span>`;
      }).join('');
      
      // ã²ã‚‰ãŒãªï¼ˆä¸‹ã«è¡¨ç¤ºã€å¯¿å¸æ‰“é¢¨ï¼‰- ã“ã¡ã‚‰ã¯æ­£ç¢º
      hiraganaEl.innerHTML = hiraganaChars.map((char, i) => {
        let className = 'hiragana-char';
        if (i < currentIndex) {
          className += ' completed';  // ç°è‰²
        } else if (i === currentIndex) {
          className += ' current';    // é’è‰²ã€å¤ªå­—
        } else {
          className += ' pending';    // é€šå¸¸
        }
        return `<span class="${className}">${char}</span>`;
      }).join('');
    }
    
    // å˜èªã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
    function startWordTimer() {
      // å‰ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
      stopWordTimer();
      
      // åˆ¶é™æ™‚é–“ã‚’è¨ˆç®—ï¼ˆ1æ–‡å­—ã‚ãŸã‚Š3ç§’ + åŸºæœ¬2ç§’ï¼‰
      const charCount = currentWord.hiragana.length;
      wordTimeLimit = charCount * 3 + 2;
      wordTimeRemaining = wordTimeLimit;
      
      // ã‚³ãƒ³ãƒœåˆ¤å®šã®é–¾å€¤ï¼ˆ50%ï¼‰
      comboThreshold = Math.ceil(wordTimeLimit * 0.5);
      
      // ãƒãƒ¼ã‚’ä¸€ç¬ã§ãƒªã‚»ãƒƒãƒˆï¼ˆtransitionã‚’ç„¡åŠ¹åŒ–ã—ã¦100%ã«æˆ»ã™ï¼‰
      const bar = document.getElementById('wordTimerBar');
      if (bar) {
        bar.style.transition = 'none';
        bar.style.width = '100%';
        bar.classList.remove('warning', 'danger');
        // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§transitionã‚’å¾©æ´»
        requestAnimationFrame(() => {
          bar.style.transition = 'width 1s linear, background 0.5s';
        });
      }
      
      // ã‚³ãƒ³ãƒœãƒãƒ¼ã‚«ãƒ¼ã®ä½ç½®ã‚’è¨­å®šï¼ˆcomboThreshold / wordTimeLimit = 50%ï¼‰
      const marker = document.getElementById('comboMarker');
      if (marker) {
        const markerPct = (comboThreshold / wordTimeLimit) * 100;
        marker.style.left = markerPct + '%';
      }
      
      // UIæ›´æ–°
      updateWordTimeDisplay();
      
      // ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
      wordTimerInterval = setInterval(() => {
        wordTimeRemaining--;
        updateWordTimeDisplay();
        
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆãƒãƒ¼ã®è¡¨ç¤ºæ›´æ–°ã‚’å¾…ã£ã¦ã‹ã‚‰æ¼”å‡ºã‚’é–‹å§‹ï¼‰
        if (wordTimeRemaining <= 0) {
          clearInterval(wordTimerInterval);  // ã‚¿ã‚¤ãƒãƒ¼åœæ­¢ï¼ˆé‡è¤‡å®Ÿè¡Œé˜²æ­¢ï¼‰
          wordTimerInterval = null;
          // è¡¨ç¤ºæ›´æ–°ãŒå®Œäº†ã™ã‚‹ã¾ã§å°‘ã—å¾…ã¤ï¼ˆ200msï¼‰
          setTimeout(() => {
            onWordTimeout();
          }, 200);
        }
      }, 1000);
    }
    
    // å˜èªã‚¿ã‚¤ãƒãƒ¼åœæ­¢
    function stopWordTimer() {
      if (wordTimerInterval) {
        clearInterval(wordTimerInterval);
        wordTimerInterval = null;
      }
    }
    
    // å˜èªã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºæ›´æ–°
    function updateWordTimeDisplay() {
      const display = document.getElementById('wordTimeDisplay');
      const bar = document.getElementById('wordTimerBar');
      
      if (wordTimeRemaining > 0) {
        display.textContent = wordTimeRemaining;
        if (wordTimeRemaining <= 3) {
          display.style.color = '#f44336';
          display.style.fontWeight = 'bold';
        } else {
          display.style.color = '';
          display.style.fontWeight = '';
        }
      } else {
        display.textContent = '0';
        display.style.color = '#f44336';
      }
      
      // å˜èªã‚¿ã‚¤ãƒãƒ¼ãƒãƒ¼æ›´æ–°
      if (bar && wordTimeLimit > 0) {
        const pct = Math.max(0, wordTimeRemaining / wordTimeLimit * 100);
        bar.style.width = pct + '%';
        
        bar.classList.remove('warning', 'danger');
        if (pct <= 25) {
          bar.classList.add('danger');
        } else if (pct <= 50) {
          bar.classList.add('warning');
        }
      }
      
      // ã‚³ãƒ³ãƒœãƒãƒ¼ã‚«ãƒ¼ã®é€šéçŠ¶æ…‹ã‚’æ›´æ–°
      const marker = document.getElementById('comboMarker');
      if (marker) {
        const inComboZone = wordTimeRemaining >= comboThreshold;
        if (inComboZone) {
          // ã‚³ãƒ³ãƒœåœå†…: é‡‘è‰²ã§è¼ã
          marker.style.opacity = '1';
          marker.style.background = '#ffd700';
          marker.style.boxShadow = '0 0 6px rgba(255,215,0,0.9), 0 0 12px rgba(255,215,0,0.5)';
        } else {
          // ã‚³ãƒ³ãƒœåœå¤–: æš—ããªã‚‹
          marker.style.opacity = '0.35';
          marker.style.background = '#888';
          marker.style.boxShadow = 'none';
        }
      }
    }
    
    // ã‚³ãƒ³ãƒœè¡¨ç¤ºæ›´æ–°
    function updateComboDisplay() {
      const comboEl = document.getElementById('comboDisplay');
      if (combo >= 2) {
        comboEl.textContent = `${combo} COMBO!`;
        comboEl.style.display = 'inline-block';
        comboEl.style.marginLeft = '10px';
        comboEl.style.padding = '3px 8px';
        comboEl.style.borderRadius = '12px';
        comboEl.style.fontWeight = 'bold';
        comboEl.style.animation = 'comboPulse 0.5s ease-in-out';
        
        // ã‚³ãƒ³ãƒœæ•°ã«å¿œã˜ã¦è‰²å¤‰æ›´
        if (combo >= 10) {
          comboEl.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
          comboEl.style.color = '#fff';
        } else if (combo >= 5) {
          comboEl.style.background = 'linear-gradient(135deg, #ffd200 0%, #ff6b00 100%)';
          comboEl.style.color = '#fff';
        } else {
          comboEl.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
          comboEl.style.color = '#fff';
        }
      } else {
        comboEl.style.display = 'none';
      }
    }
    
    // ã‚³ãƒ³ãƒœã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤º
    function showComboEffect(comboCount, timeBonus) {
      // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¦ç´ ã‚’ä½œæˆ
      const effect = document.createElement('div');
      effect.style.position = 'fixed';
      effect.style.top = '50%';
      effect.style.left = '50%';
      effect.style.transform = 'translate(-50%, -50%)';
      effect.style.fontSize = '72px';
      effect.style.fontWeight = 'bold';
      effect.style.zIndex = '9999';
      effect.style.pointerEvents = 'none';
      effect.style.textShadow = '0 0 20px rgba(255,255,255,0.8)';
      
      if (timeBonus > 0) {
        effect.textContent = `${comboCount} COMBO!\n+${timeBonus}ç§’`;
        effect.style.background = 'linear-gradient(135deg, #ffd200 0%, #ff6b00 100%)';
        effect.style.webkitBackgroundClip = 'text';
        effect.style.webkitTextFillColor = 'transparent';
        effect.style.backgroundClip = 'text';
      } else {
        effect.textContent = `${comboCount} COMBO!`;
        effect.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
        effect.style.webkitBackgroundClip = 'text';
        effect.style.webkitTextFillColor = 'transparent';
        effect.style.backgroundClip = 'text';
      }
      
      effect.style.animation = 'comboEffect 1s ease-out';
      effect.style.whiteSpace = 'pre-line';
      effect.style.textAlign = 'center';
      
      document.body.appendChild(effect);
      
      // 1ç§’å¾Œã«å‰Šé™¤
      setTimeout(() => {
        effect.remove();
      }, 1000);
    }
    
    // NGã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤º
    function showNGEffect(word) {
      // ã‚²ãƒ¼ãƒ ä¸­ã®ã¿è¡¨ç¤º
      if (!isPlaying) return;
      
      // TIMEOUTæ–‡å­—ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãƒ»è»½é‡ï¼‰
      const effect = document.createElement('div');
      effect.dataset.ngEffect = '1';
      effect.style.position = 'fixed';
      effect.style.top = '50%';
      effect.style.left = '50%';
      effect.style.transform = 'translate(-50%, -50%)';
      effect.style.fontSize = '64px';
      effect.style.fontWeight = '800';
      effect.style.zIndex = '9999';
      effect.style.pointerEvents = 'none';
      effect.style.color = '#f44336';
      effect.style.textShadow = '0 2px 12px rgba(0,0,0,0.5)';
      effect.style.animation = 'ngEffect 0.7s ease-out';
      effect.style.letterSpacing = '2px';
      effect.textContent = 'TIMEOUT';
      
      document.body.appendChild(effect);
      setTimeout(() => effect.remove(), 700);
    }
    
    // å˜èªã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®å‡¦ç†
    function onWordTimeout() {
      stopWordTimer();
      
      // ã‚²ãƒ¼ãƒ çµ‚äº†æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
      if (!isPlaying) return;
      
      // ã‚³ãƒ³ãƒœé€”åˆ‡ã‚Œ: ä¸¡æ–¹ãƒªã‚»ãƒƒãƒˆ
      if (combo > 0) {

      }
      combo = 0;
      bonusCombo = 0;
      updateComboDisplay();
      
      // ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼ˆå˜èªã®é•·ã• Ã— -10ç‚¹ï¼‰
      const penalty = currentWord.hiragana.length * -10;
      score += penalty;
      missedWords++;
      
      document.getElementById('currentScore').textContent = score;
      document.getElementById('statusBox').textContent = 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ ' + penalty + 'ç‚¹';
      document.getElementById('statusBox').style.background = '#ffebee';
      
      // NGã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤º
      showNGEffect(currentWord.display);
      
      // 0.7ç§’å¾Œã«æ¬¡ã®å˜èªã¸ï¼ˆã‚²ãƒ¼ãƒ çµ‚äº†æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„ï¼‰
      setTimeout(() => {
        if (!isPlaying) return;
        document.getElementById('statusBox').textContent = 'æ‰‹ã‚’ã‚«ãƒ¡ãƒ©ã«æ˜ ã—ã¦ãã ã•ã„';
        document.getElementById('statusBox').style.background = '#e3f2fd';
        nextWord();
      }, 700);
    }
    
    // ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
    // å…¨ä½“ã‚¿ã‚¤ãƒãƒ¼ãƒãƒ¼æ›´æ–°
    function updateTotalTimerBar() {
      const bar = document.getElementById('totalTimerBar');
      if (!bar) return;
      const pct = Math.max(0, timeRemaining / timeLimit * 100);
      bar.style.width = pct + '%';
      
      // è‰²å¤‰åŒ–
      bar.classList.remove('warning', 'danger');
      if (pct <= 20) {
        bar.classList.add('danger');
      } else if (pct <= 40) {
        bar.classList.add('warning');
      }
    }
    
    function startTimer() {
      document.getElementById('timeRemaining').textContent = timeRemaining;
      updateTotalTimerBar();
      
      timerInterval = setInterval(() => {
        timeRemaining--;
        document.getElementById('timeRemaining').textContent = timeRemaining;
        updateTotalTimerBar();
        
        if (timeRemaining <= 0) {
          clearInterval(timerInterval);
          gameOver();
        }
      }, 1000);
    }
    
    // æ‰‹è©±èªè­˜ãƒ«ãƒ¼ãƒ—
    async function loop() {
      if (!isPlaying) return;
      
      const now = performance.now();
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      
      // MediaPipeæ¤œå‡º
      const res = landmarker.detectForVideo(video, now);
      drawHands(res);
      
      // æ‰‹ã®æ¤œå‡ºãƒã‚§ãƒƒã‚¯
      if (res?.landmarks?.length > 0) {
        // å³æ‰‹ã®ã¿ã‚’ä½¿ç”¨ï¼ˆquiz_unified.htmlã¨åŒã˜ï¼‰
        let idx = 0;
        if (res.handednesses?.length) {
          const iRight = res.handednesses.findIndex(h => h?.[0]?.categoryName === "Right");
          if (iRight !== -1) {
            idx = iRight;
          }
        }
        
        const landmarks = res.landmarks[idx];
        const features = toFeature63(landmarks);
        
        // æ¨è«–
        await predictSign(features);
      } else {
        document.getElementById('recognizedChar').textContent = '-';
        document.getElementById('confidenceDisplay').textContent = 'æ‰‹ãŒè¦‹ãˆã¾ã›ã‚“';
        document.getElementById('statusBox').textContent = 'æ‰‹ã‚’ã‚«ãƒ¡ãƒ©ã«æ˜ ã—ã¦ãã ã•ã„';
      }
      
      rafId = requestAnimationFrame(loop);
    }
    
    // æ‰‹ã®æç”»
    function drawHands(res) {
      const canvas = document.getElementById('canvas');
      const video = document.getElementById('video');
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(video, 0, 0, w, h);
      
      if (res?.landmarks?.length > 0) {
        for (const landmarks of res.landmarks) {
          // æ¥ç¶šç·š
          const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17]
          ];
          
          // æ·±æµ·ãƒ†ãƒ¼ãƒ: ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³
          ctx.shadowBlur = 6;
          ctx.shadowColor = "rgba(100, 220, 255, 0.8)";
          ctx.strokeStyle = "rgba(100, 220, 255, 0.55)";
          ctx.lineWidth = 1.5;

          for (const [start, end] of connections) {
            const p1 = landmarks[start];
            const p2 = landmarks[end];
            if (p1 && p2) {
              ctx.beginPath();
              ctx.moveTo(p1.x * w, p1.y * h);
              ctx.lineTo(p2.x * w, p2.y * h);
              ctx.stroke();
            }
          }

          // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ç‚¹
          ctx.shadowBlur = 8;
          ctx.shadowColor = "rgba(50, 150, 255, 0.9)";
          ctx.fillStyle = "rgba(80, 180, 255, 0.9)";
          for (const p of landmarks) {
            ctx.beginPath();
            ctx.arc(p.x * w, p.y * h, 3, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.shadowBlur = 0;
        }
      }
    }
    
    // ç‰¹å¾´é‡æŠ½å‡º
    function toFeature63(landmarks) {
      // å³æ‰‹: ãƒŸãƒ©ãƒ¼ã‚ã‚Šï¼ˆå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã®åéŒ²æ¡ä»¶ï¼‰/ å·¦æ‰‹: ãƒŸãƒ©ãƒ¼ãªã—ï¼ˆå·¦æ‰‹ç”Ÿåº§æ¨™â‰’å³æ‰‹ãƒŸãƒ©ãƒ¼åƒï¼‰
      const mirror = (selectedHand === 'right');
      const wrist = landmarks[0];
      
      const pts = landmarks.map(p => ({
        x: (mirror ? (1.0 - p.x) : p.x) - (mirror ? (1.0 - wrist.x) : wrist.x),
        y: p.y - wrist.y,
        z: p.z - wrist.z
      }));
      
      let maxd = 0;
      for (const p of pts) {
        const d = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
        if (d > maxd) maxd = d;
      }
      
      const s = (maxd > 1e-9) ? (1.0 / maxd) : 1.0;
      const vec = [];
      for (const p of pts) {
        vec.push(p.x * s, p.y * s, p.z * s);
      }
      
      return vec;
    }
    
    // æ‰‹è©±èªè­˜
    let frameBuffer = [];
    const TARGET_FRAMES = 15;
    
    async function predictSign(features) {
      frameBuffer.push(features);
      if (frameBuffer.length > 20) {
        frameBuffer.shift();
      }
      
      if (frameBuffer.length < TARGET_FRAMES) return;
      
      const frames15 = resampleTo15(frameBuffer.slice(-18));
      const inputTensor = tf.tensor3d([frames15], [1, TARGET_FRAMES, 63]);
      
      const output = await model.executeAsync(inputTensor);
      const probs = await output.data();
      
      inputTensor.dispose();
      output.dispose();
      
      const predId = Array.from(probs).indexOf(Math.max(...probs));
      const conf = probs[predId];
      const sign = labelMap.id_to_label[String(predId)];
      
      // è‹±èªãƒ©ãƒ™ãƒ«ã‚’æ—¥æœ¬èªã«å¤‰æ›ï¼ˆè¡¨ç¤ºç”¨ï¼‰
      const displaySign = convertToHiragana(sign);
      
      // UIæ›´æ–°
      document.getElementById('recognizedChar').textContent = displaySign;
      document.getElementById('confidenceDisplay').textContent = `${(conf * 100).toFixed(1)}%`;
      
      // åˆ¤å®š
      if (conf >= 0.80) {
        onSignRecognized(sign);
      }
    }
    
    function resampleTo15(frames) {
      const n = frames.length;
      if (n === TARGET_FRAMES) return frames;
      
      if (n < TARGET_FRAMES) {
        const result = [...frames];
        while (result.length < TARGET_FRAMES) {
          result.push(frames[frames.length - 1]);
        }
        return result;
      }
      
      const indices = [];
      for (let i = 0; i < TARGET_FRAMES; i++) {
        indices.push(i * (n - 1) / (TARGET_FRAMES - 1));
      }
      
      return indices.map(idx => {
        const i0 = Math.floor(idx);
        const i1 = Math.min(i0 + 1, n - 1);
        const alpha = idx - i0;
        return frames[i0].map((v, j) => v * (1 - alpha) + frames[i1][j] * alpha);
      });
    }
    
    // èªè­˜çµæœã®å‡¦ç†
    function onSignRecognized(sign) {
      // è‹±èªãƒ©ãƒ™ãƒ«ã‚’æ—¥æœ¬èªã«å¤‰æ›
      const hiraganaSign = convertToHiragana(sign);
      const expectedChar = currentWord.hiragana[currentIndex];
      
      if (isMatch(hiraganaSign, expectedChar)) {
        onCharacterCorrect();
      }
    }
    
    // ãƒãƒƒãƒãƒ³ã‚°åˆ¤å®šï¼ˆæ¿éŸ³è£œæ­£ï¼‹æ–‡å­—ã‚°ãƒ«ãƒ¼ãƒ—å¯¾å¿œï¼‰
    function isMatch(recognized, expected) {
      // 1. ç›´æ¥ä¸€è‡´
      if (recognized === expected) return true;
      
      // 2. ã‚¨ã‚¤ãƒªã‚¢ã‚¹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚’/å°ãŠ ãªã©ï¼‰
      if (aliases[expected]) {
        if (aliases[expected].includes(recognized)) {

          return true;
        }
      }
      
      // 3. æ¿éŸ³â†’æ¸…éŸ³ã®è£œæ­£
      // ä¾‹: èªè­˜ã€Œã°ã€â†’ æ¸…éŸ³ã€Œã¯ã€â†’ æœŸå¾…ã€Œã¯ã€ãªã‚‰ OK
      if (dakuonToSeion[recognized]) {
        const seion = dakuonToSeion[recognized];
        if (seion === expected) {

          return true;
        }
      }
      
      // 4. å°ã•ã„æ–‡å­—â†’å¤§ãã„æ–‡å­—ã®è£œæ­£ï¼ˆä¸€æ–¹å‘ã®ã¿ï¼‰
      // ä¾‹: èªè­˜ã€Œãã€â†’ å¤§æ–‡å­—ã€Œã‚ã€â†’ æœŸå¾…ã€Œã‚ã€ãªã‚‰ OK
      if (komojiToOmoji[recognized]) {
        const omoji = komojiToOmoji[recognized];
        if (omoji === expected) {

          return true;
        }
      }
      
      // 5. æ–‡å­—ã‚°ãƒ«ãƒ¼ãƒ—ãƒã‚§ãƒƒã‚¯ï¼ˆç›¸äº’èªè­˜ï¼‰
      // ä¾‹: ã‚°ãƒ«ãƒ¼ãƒ—["ã¯", "ã°", "ã±"] â†’ èªè­˜ã€Œã°ã€ã€æœŸå¾…ã€Œã¯ã€ã§ã‚‚ OK
      if (isInSameGroup(recognized, expected)) {

        return true;
      }
      
      return false;
    }
    
    // æ­£è§£æ™‚ã®å‡¦ç†
    function onCharacterCorrect() {
      const charTime = performance.now() - charStartTime;
      totalTime += charTime;
      totalChars++;
      
      currentIndex++;
      updateWordDisplay();
      updateStats();
      
      if (currentIndex >= currentWord.hiragana.length) {
        onWordComplete();
      } else {
        charStartTime = performance.now();
      }
    }
    
    // å˜èªå®Œæˆ
    function onWordComplete() {
      stopWordTimer();
      
      clearedCount++;
      score += currentWord.hiragana.length * 10;
      SEA.updateScore(totalChars);  // æ·±æµ·æ¼”å‡ºã‚’ç´¯è¨ˆæ–‡å­—æ•°ã§æ›´æ–°
      
      // ã‚³ãƒ³ãƒœåˆ¤å®šï¼ˆåˆ¶é™æ™‚é–“ã®50%ä»¥ä¸Šæ®‹ã£ã¦ã„ã‚Œã°ã‚³ãƒ³ãƒœï¼‰
      const isCombo = wordTimeRemaining >= comboThreshold;
      
      if (isCombo) {
        // è¡¨ç¤ºç”¨ã‚³ãƒ³ãƒœ: é€”åˆ‡ã‚Œã‚‹ã¾ã§å¢—åŠ ã—ç¶šã‘ã‚‹
        combo++;
        if (combo > maxCombo) maxCombo = combo;
        
        // ãƒœãƒ¼ãƒŠã‚¹åˆ¤å®šç”¨ã‚³ãƒ³ãƒœ: 10é”æˆã§ãƒªã‚»ãƒƒãƒˆ
        bonusCombo++;
        
        let bonus = 0;
        
        if (bonusCombo === 3) {
          bonus = 2;
        } else if (bonusCombo === 5) {
          bonus = 3;
        } else if (bonusCombo === 10) {
          bonus = 5;
          bonusCombo = 0; // ãƒœãƒ¼ãƒŠã‚¹ã‚«ã‚¦ãƒ³ã‚¿ã®ã¿ãƒªã‚»ãƒƒãƒˆ

        }
        
        // ã‚¿ã‚¤ãƒ ãƒœãƒ¼ãƒŠã‚¹ä»˜ä¸
        if (bonus > 0) {
          timeRemaining += bonus;
          document.getElementById('timeRemaining').textContent = timeRemaining;
          updateTotalTimerBar();
          showComboEffect(combo, bonus);
        }
        
        // ã‚³ãƒ³ãƒœè¡¨ç¤ºæ›´æ–°ï¼ˆè¡¨ç¤ºç”¨comboã§æ›´æ–°ï¼‰
        updateComboDisplay();
      } else {
        // ã‚³ãƒ³ãƒœé€”åˆ‡ã‚Œ: ä¸¡æ–¹ãƒªã‚»ãƒƒãƒˆ
        if (combo > 0) {

        }
        combo = 0;
        bonusCombo = 0;
        updateComboDisplay();
      }
      
      document.getElementById('clearedCount').textContent = clearedCount;
      document.getElementById('currentScore').textContent = score;
      
      nextWord();
    }
    
    // çµ±è¨ˆæ›´æ–°
    function updateStats() {
      const seconds = totalTime / 1000;
      const cps = seconds > 0 ? (totalChars / seconds).toFixed(2) : '0.00';
      document.getElementById('speedDisplay').textContent = cps;
    }
    
    // ã‚²ãƒ¼ãƒ çµ‚äº†
    function gameOver() {
      isPlaying = false;
      if (rafId) cancelAnimationFrame(rafId);
      stopWordTimer();  // å˜èªã‚¿ã‚¤ãƒãƒ¼åœæ­¢
      
      // ç”»é¢ä¸Šã«æ®‹ã£ã¦ã„ã‚‹NGã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ»ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚’å¼·åˆ¶å‰Šé™¤
      document.querySelectorAll('[data-ng-effect]').forEach(el => el.remove());
      
      const seconds = totalTime / 1000;
      const cps = seconds > 0 ? (totalChars / seconds).toFixed(2) : '0.00';
      
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalCleared').textContent = clearedCount;
      document.getElementById('finalChars').textContent = totalChars;
      document.getElementById('finalSpeed').textContent = cps + ' æ–‡å­—/ç§’';
      
      // ç§°å·å–å¾—
      loadTitleAndShow(score);
      
      // åˆ°é”ã‚¹ãƒ†ãƒ¼ã‚¸è¡¨ç¤º
      loadStageAndShow(totalChars);
      
      // ãƒã‚¤ã‚¹ã‚³ã‚¢ãƒã‚§ãƒƒã‚¯
      checkHighScore(score);
      
      // ã‚¹ã‚³ã‚¢ä¿å­˜
      saveScore(score, clearedCount, cps);
      
      // çµæœç”»é¢è¡¨ç¤º
      document.getElementById('resultScreen').classList.add('show');
    }
    
    // ç§°å·èª­ã¿è¾¼ã¿
    async function loadTitleAndShow(score) {
      try {
        const response = await fetch('./data/titles.json?v=' + Date.now());
        const data = await response.json();
        
        let title = data.titles[0];
        for (const t of data.titles) {
          if (score >= t.minScore && score <= t.maxScore) {
            title = t;
            break;
          }
        }
        
        document.getElementById('titleEmoji').textContent = title.emoji;
        document.getElementById('titleText').textContent = title.title;
        
        // ç§°å·ã‚’localStorageã®æœ€æ–°ã‚¹ã‚³ã‚¢ã«è¿½è¨˜
        try {
          const scores = JSON.parse(localStorage.getItem('allScores') || '[]');
          if (scores.length > 0) {
            scores[scores.length - 1].titleText  = title.title;
            scores[scores.length - 1].titleEmoji = title.emoji;
            localStorage.setItem('allScores', JSON.stringify(scores));
          }
        } catch(e) {}
        
      } catch (error) {
        console.error('ç§°å·èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
        document.getElementById('titleEmoji').textContent = 'â­';
        document.getElementById('titleText').textContent = 'å‚åŠ è³';
      }
    }
    
    // åˆ°é”ã‚¹ãƒ†ãƒ¼ã‚¸èª­ã¿è¾¼ã¿
    async function loadStageAndShow(totalChars) {
      try {
        const response = await fetch('./data/stage.json?v=' + Date.now());
        const data = await response.json();
        
        // totalCharsã‹ã‚‰åˆ°é”ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’æ±ºå®š
        let stage = data.stages[0];
        for (const s of data.stages) {
          if (totalChars >= s.minChars) {
            stage = s;
          } else {
            break;
          }
        }
        
        // æ·±åº¦è¨ˆç®—ï¼ˆæ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¾ã§ã®é€²æ—ã§è£œé–“ï¼‰
        const currentIndex = data.stages.indexOf(stage);
        const nextStage = data.stages[currentIndex + 1];
        let depth = stage.depth;
        
        if (nextStage) {
          const progress = (totalChars - stage.minChars) / (nextStage.minChars - stage.minChars);
          depth = Math.round(stage.depth + (nextStage.depth - stage.depth) * Math.min(1, progress));
        } else {
          // æœ€çµ‚ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’è¶…ãˆãŸå ´åˆ
          depth = Math.round(stage.depth + (totalChars - stage.minChars) * 15);
        }
        
        // è¡¨ç¤º
        document.getElementById('stageResultIcon').textContent = stage.icon;
        document.getElementById('stageResultName').textContent = stage.name;
        document.getElementById('stageResultDepth').textContent = `â–¼ ${depth.toLocaleString()}m`;
        document.getElementById('stageResultComment').textContent = stage.comment;
        
        // ã‚¹ãƒšã‚·ãƒ£ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ã®ã‚¢ãƒ³ãƒ­ãƒƒã‚¯å‡¦ç†
        // ä¸­å±¤ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹4ï¼‰ä»¥é™ãŒã‚¹ãƒšã‚·ãƒ£ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸
        if (currentIndex >= 4) {
          const specialStageNumber = currentIndex - 3; // 4â†’1, 5â†’2, 6â†’3, 7â†’4, 8â†’5
          
          // localStorageã«ä¿å­˜ï¼ˆç·´ç¿’ãƒ¢ãƒ¼ãƒ‰ã§ä½¿ç”¨ï¼‰
          const currentMaxStage = localStorage.getItem('signDiverMaxStage') || '0';
          const currentMax = parseInt(currentMaxStage);
          
          if (specialStageNumber > currentMax) {
            localStorage.setItem('signDiverMaxStage', specialStageNumber.toString());


            
            // ã‚¢ãƒ³ãƒ­ãƒƒã‚¯é€šçŸ¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šå¿…è¦ã«å¿œã˜ã¦UIã§è¡¨ç¤ºï¼‰
            const specialNames = {
              1: 'ä¸­å±¤',
              2: 'è–„æš®å±¤', 
              3: 'æ·±æµ·',
              4: 'è¶…æ·±æµ·',
              5: '???'
            };

          }
        }
        
      } catch (error) {
        console.error('ã‚¹ãƒ†ãƒ¼ã‚¸èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
        document.getElementById('stageResultIcon').textContent = 'ğŸ–ï¸';
        document.getElementById('stageResultName').textContent = 'æµ…ç€¬';
        document.getElementById('stageResultDepth').textContent = 'â–¼ 0m';
        document.getElementById('stageResultComment').textContent = 'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
      }
    }
    
    // ãƒã‚¤ã‚¹ã‚³ã‚¢ãƒã‚§ãƒƒã‚¯
    function checkHighScore(newScore) {
      const key = `highScore_${difficulty}_${timeLimit}`;
      const highScore = localStorage.getItem(key);
      
      if (!highScore || newScore > parseInt(highScore)) {
        localStorage.setItem(key, newScore);
        document.getElementById('highScoreNotice').style.display = 'block';
      }
    }
    
    // ã‚¹ã‚³ã‚¢ä¿å­˜
    function saveScore(score, cleared, speed) {
      const scores = JSON.parse(localStorage.getItem('allScores') || '[]');
      
      scores.push({
        score,
        cleared,
        speed,
        totalChars,
        difficulty,
        timeLimit,
        date: new Date().toISOString()
      });
      
      // æœ€æ–°100ä»¶ã®ã¿ä¿å­˜
      if (scores.length > 100) {
        scores.shift();
      }
      
      localStorage.setItem('allScores', JSON.stringify(scores));
    }
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°
    window.retry = function() {
      window.location.reload();
    };
    
    const SITE_URL = 'https://h-takayasu.github.io/sign-diver/';

    window.shareToX = function() {
      const score = document.getElementById('finalScore').textContent;
      const speed = document.getElementById('finalSpeed').textContent;
      const text = `æŒ‡æ–‡å­—ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚²ãƒ¼ãƒ  Sign Diver ã§ ${score}ç‚¹ï¼ˆ${speed}ï¼‰ã‚’è¨˜éŒ²ã—ã¾ã—ãŸï¼ #SignDiver #æŒ‡æ–‡å­—`;
      const url = `https://x.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(SITE_URL)}`;
      window.open(url, '_blank', 'width=550,height=450');
    };

    window.shareToLINE = function() {
      const score = document.getElementById('finalScore').textContent;
      const text = `æŒ‡æ–‡å­—ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚²ãƒ¼ãƒ  Sign Diver ã§ ${score}ç‚¹å–ã‚ŒãŸï¼ã‚„ã£ã¦ã¿ã¦ ğŸ‘‰ ${SITE_URL}`;
      const url = `https://social-plugins.line.me/lineit/share?url=${encodeURIComponent(SITE_URL)}&text=${encodeURIComponent(text)}`;
      window.open(url, '_blank');
    };

    window.backToMenu = function() {
      window.location.href = 'index.html';
    };
    
    // Escã‚­ãƒ¼ã§ä¸­æ–­
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && isPlaying) {
        const confirmQuit = confirm('ã‚²ãƒ¼ãƒ ã‚’ä¸­æ–­ã—ã¾ã™ã‹ï¼Ÿ');
        if (confirmQuit) {
          window.location.href = 'index.html';
        }
      }
    });
    
    // =============================================
    // æ·±æµ·ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
    // =============================================
    
    const SEA = {
      canvas: null,
      ctx: null,
      W: 0,
      H: 0,
      raf: null,
      
      // æ·±åº¦ãƒ¬ãƒ™ãƒ«å®šç¾©ï¼ˆminChars = ç´¯è¨ˆã‚¯ãƒªã‚¢æ–‡å­—æ•°ï¼‰
      LEVELS: [
        { minChars:   0, depth:     0, name: 'æµ…ç€¬',     bg1: '#00bfff', bg2: '#0099cc', rays: 1.0,  creatures: ['fish']                   },
        { minChars:   8, depth:    10, name: 'çŠç‘šç¤',   bg1: '#0099cc', bg2: '#0077aa', rays: 0.85, creatures: ['katsuo', 'shrimp']        },
        { minChars:  18, depth:    30, name: 'æµ…æµ·',     bg1: '#0077aa', bg2: '#005588', rays: 0.70, creatures: ['saba', 'starfish']        },
        { minChars:  32, depth:    80, name: 'æ½®ç›®',     bg1: '#005588', bg2: '#003366', rays: 0.50, creatures: ['katsuo', 'rakko']          },
        { minChars:  48, depth:   200, name: 'ä¸­å±¤',     bg1: '#003366', bg2: '#001f44', rays: 0.30, creatures: ['jellyfish', 'seaweed']    },
        { minChars:  68, depth:   500, name: 'è–„æš®å±¤',   bg1: '#001f44', bg2: '#000e22', rays: 0.12, creatures: ['shark', 'jellyfish']      },
        { minChars:  92, depth:  1000, name: 'æ·±æµ·',     bg1: '#000e22', bg2: '#000511', rays: 0.04, creatures: ['anglerfish', 'clam']      },
        { minChars: 120, depth:  3000, name: 'è¶…æ·±æµ·',   bg1: '#000511', bg2: '#000000', rays: 0.0,  creatures: ['anglerfish', 'mussel']    },
        { minChars: 150, depth: 10000, name: '???', bg1: '#0a0015', bg2: '#020010', rays: 0.0,  creatures: ['diver2']                 },
      ],
      
      currentDepth: 0,
      targetDepth: 0,
      currentLevel: 0,
      
      // ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ï¼šç¾åœ¨æç”»ã«ä½¿ã£ã¦ã„ã‚‹è‰²ï¼ˆãªã‚ã‚‰ã‹ã«é·ç§»ï¼‰
      renderBg1: '#0099cc',
      renderBg2: '#006699',
      renderRays: 1.0,
      fadeFrom1: '#0099cc',
      fadeFrom2: '#006699',
      fadeFromRay: 1.0,
      fadeProgress: 1,   // 1=ãƒ•ã‚§ãƒ¼ãƒ‰å®Œäº†æ¸ˆã¿ï¼ˆåˆæœŸçŠ¶æ…‹ï¼‰
      
      bubbles: [],
      particles: [],        // æµ®éŠå¡µ
      creatures: [],        // é­š/ã‚¯ãƒ©ã‚²
      diverY: 0,            // ãƒ€ã‚¤ãƒãƒ¼Yåº§æ¨™
      time: 0,
      
      init() {
        this.canvas = document.getElementById('seaCanvas');
        if (!this.canvas) return;
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.diverY = this.H * 0.5;
        this.spawnInitial();
        this.animate();
      },
      
      resize() {
        if (!this.canvas) return;
        const wrap = this.canvas.parentElement;
        // clientWidthãŒ0ã®å ´åˆã¯offsetWidthã§ä»£æ›¿
        this.W = wrap.clientWidth || wrap.offsetWidth || 800;
        this.H = wrap.clientHeight || wrap.offsetHeight || 200;
        this.canvas.width  = this.W;
        this.canvas.height = this.H;
        this.diverY = this.H * 0.5;
      },
      
      // ç´¯è¨ˆã‚¯ãƒªã‚¢æ–‡å­—æ•°ã‹ã‚‰ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
      getLevel(chars) {
        let lv = 0;
        for (let i = 0; i < this.LEVELS.length; i++) {
          if (chars >= this.LEVELS[i].minChars) lv = i;
        }
        return lv;
      },
      
      // ç´¯è¨ˆã‚¯ãƒªã‚¢æ–‡å­—æ•°ãŒå¤‰åŒ–ã—ãŸæ™‚ã«å‘¼ã¶
      updateScore(chars) {
        const lv = this.getLevel(chars);
        const L  = this.LEVELS[lv];
        const nextLv = this.LEVELS[lv + 1];
        
        // æ¬¡ãƒ¬ãƒ™ãƒ«ã¾ã§ã®é€²æ—ã§æ·±åº¦ã‚’è£œé–“
        if (nextLv) {
          const progress = (chars - L.minChars) / (nextLv.minChars - L.minChars);
          this.targetDepth = L.depth + (nextLv.depth - L.depth) * progress;
        } else {
          this.targetDepth = L.depth + (chars - L.minChars) * 15;
        }
        
        // ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã£ãŸã‚‰ã‚¯ãƒªãƒ¼ãƒãƒ£ãƒ¼ã‚’è£œå……ï¼†ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹
        if (lv !== this.currentLevel) {
          // ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ï¼šç¾åœ¨ã®è‰²ã‚’èµ·ç‚¹ã¨ã—ã¦ä¿å­˜
          this.fadeFrom1   = this.renderBg1;
          this.fadeFrom2   = this.renderBg2;
          this.fadeFromRay = this.renderRays;
          this.fadeProgress = 0;  // 0â†’1 ã§ç·šå½¢ãƒ•ã‚§ãƒ¼ãƒ‰
          this.currentLevel = lv;
          this.creatures = [];
          this.spawnCreatures();
        }
      },
      
      spawnInitial() {
        // æ³¡
        for (let i = 0; i < 18; i++) this.addBubble(true);
        // æµ®éŠå¡µ
        for (let i = 0; i < 30; i++) this.addParticle(true);
        // ç”Ÿãç‰©
        this.spawnCreatures();
      },
      
      spawnCreatures() {
        const types = this.LEVELS[this.currentLevel].creatures;
        // diver2ã¯ç”»é¢ä¸­å¤®ã«1ä½“ã®ã¿å›ºå®šé…ç½®
        if (types.includes('diver2')) {
          this.addCreature('diver2', true);
          return;
        }
        const isSparse = types.includes('anglerfish') || types.includes('rakko');
        const count = isSparse ? 2 : 4;
        for (let i = 0; i < count; i++) {
          const type = types[Math.floor(Math.random() * types.length)];
          this.addCreature(type, true);
        }
      },
      
      addBubble(randomY = false) {
        this.bubbles.push({
          x: Math.random() * this.W,
          y: randomY ? Math.random() * this.H : this.H + 10,
          r: 1.5 + Math.random() * 4,
          speed: 0.4 + Math.random() * 0.8,
          wobble: Math.random() * Math.PI * 2,
          opacity: 0.3 + Math.random() * 0.4
        });
      },
      
      addParticle(randomY = false) {
        this.particles.push({
          x: Math.random() * this.W,
          y: randomY ? Math.random() * this.H : -5,
          vy: 0.05 + Math.random() * 0.15,
          vx: (Math.random() - 0.5) * 0.3,
          opacity: 0.1 + Math.random() * 0.25,
          size: 0.5 + Math.random() * 1.5
        });
      },
      
      addCreature(type, randomPos = false) {
        const fromRight = Math.random() > 0.5;
        const rx = randomPos ? Math.random() * this.W : (fromRight ? this.W + 80 : -80);
        const ry = this.H * (0.1 + Math.random() * 0.8);
        
        if (type === 'katsuo') {
          // ã‚«ãƒ„ã‚ªï¼šç¾¤ã‚Œã§æ³³ã
          const dir = fromRight ? -1 : 1;
          const baseX = randomPos ? Math.random() * this.W : (fromRight ? this.W + 80 : -80);
          const baseY = this.H * (0.15 + Math.random() * 0.7);
          const groupSize = 2 + Math.floor(Math.random() * 3);
          for (let g = 0; g < groupSize; g++) {
            this.creatures.push({
              type: 'katsuo',
              x: baseX + (randomPos ? (Math.random()-0.5)*80 : g * dir * -30),
              y: baseY + (Math.random()-0.5) * 40,
              vx: dir * (1.2 + Math.random() * 0.8),
              phase: Math.random() * Math.PI * 2,
              size: 18 + Math.random() * 10,
            });
          }
          return;
        }
        
        if (type === 'saba') {
          // ã‚µãƒï¼šã‚«ãƒ„ã‚ªã‚ˆã‚Šç´°ã‚ã€é’ç·‘ã®ç¸
          const dir = fromRight ? -1 : 1;
          this.creatures.push({
            type: 'saba',
            x: rx, y: ry,
            vx: dir * (0.8 + Math.random() * 0.6),
            phase: Math.random() * Math.PI * 2,
            size: 16 + Math.random() * 8,
          });
          return;
        }
        
        if (type === 'rakko') {
          // ãƒ©ãƒƒã‚³ï¼šå¯æ„›ã„ã€ã‚†ã£ãã‚Šã€æ™‚ã€…å›è»¢
          this.creatures.push({
            type: 'rakko',
            x: rx, y: ry,
            vx: (fromRight ? -1 : 1) * (0.25 + Math.random() * 0.25),
            phase: Math.random() * Math.PI * 2,
            size: 14 + Math.random() * 8,
            floatAngle: Math.random() * Math.PI * 2, // æµ®éŠè§’åº¦
          });
          return;
        }
        
        if (type === 'shark') {
          // ã‚µãƒ¡ï¼šå¤§ãã„ã€é€Ÿã„
          const dir = fromRight ? -1 : 1;
          this.creatures.push({
            type: 'shark',
            x: randomPos ? Math.random() * this.W : (fromRight ? this.W + 120 : -120),
            y: this.H * (0.15 + Math.random() * 0.6),
            vx: dir * (0.7 + Math.random() * 0.5),
            phase: Math.random() * Math.PI * 2,
            size: 35 + Math.random() * 20,
          });
          return;
        }
        
        if (type === 'shrimp') {
          // ã‚¨ãƒ“ï¼šå°ã•ã„ã€ã²ã‚‡ã“ã²ã‚‡ã“æ³³ã
          this.creatures.push({
            type: 'shrimp',
            x: rx, y: ry,
            vx: (fromRight ? -1 : 1) * (0.4 + Math.random() * 0.5),
            phase: Math.random() * Math.PI * 2,
            size: 10 + Math.random() * 6,
          });
          return;
        }
        
        if (type === 'starfish') {
          // ãƒ’ãƒˆãƒ‡ï¼šã‚†ã£ãã‚Šæ¼‚ã†ã€ã‚„ã‚„ä¸‹å¯„ã‚Š
          this.creatures.push({
            type: 'starfish',
            x: rx,
            y: this.H * (0.55 + Math.random() * 0.35), // ä¸‹åŠåˆ†ã«å‡ºç¾
            vx: (fromRight ? -1 : 1) * (0.1 + Math.random() * 0.15),
            phase: Math.random() * Math.PI * 2,
            size: 12 + Math.random() * 8,
            hue: 0 + Math.random() * 40, // ã‚ªãƒ¬ãƒ³ã‚¸ã€œèµ¤
          });
          return;
        }
        
        if (type === 'seaweed') {
          // ã‚ã‹ã‚ï¼šå·¦å³ã«ã‚†ã‚‰ã‚†ã‚‰ã€ã»ã¼å®šä½ç½®
          this.creatures.push({
            type: 'seaweed',
            x: randomPos ? Math.random() * this.W : (Math.random() * this.W),
            y: this.H, // åº•ã‹ã‚‰ç”Ÿãˆã‚‹
            vx: 0,     // æ¨ªç§»å‹•ãªã—ï¼ˆã‚†ã‚‰ã‚†ã‚‰ã®ã¿ï¼‰
            phase: Math.random() * Math.PI * 2,
            size: 30 + Math.random() * 30,
            hue: 140 + Math.random() * 30,
          });
          return;
        }
        
        if (type === 'clam') {
          // ã‚¢ã‚µãƒªï¼šåº•ã«ã„ã‚‹ã€ã‚†ã£ãã‚Š
          this.creatures.push({
            type: 'clam',
            x: rx,
            y: this.H * (0.7 + Math.random() * 0.2),
            vx: (fromRight ? -1 : 1) * (0.08 + Math.random() * 0.1),
            phase: Math.random() * Math.PI * 2,
            size: 9 + Math.random() * 5,
          });
          return;
        }
        
        if (type === 'mussel') {
          // ãƒ ãƒ¼ãƒ«è²ï¼šç¸¦é•·ã®è²
          this.creatures.push({
            type: 'mussel',
            x: rx,
            y: this.H * (0.65 + Math.random() * 0.25),
            vx: (fromRight ? -1 : 1) * (0.06 + Math.random() * 0.08),
            phase: Math.random() * Math.PI * 2,
            size: 10 + Math.random() * 6,
          });
          return;
        }
        
        if (type === 'jellyfish' || type === 'anglerfish') {
          this.creatures.push({
            type: type,
            x: rx, y: ry,
            vx: (fromRight ? -1 : 1) * (0.2 + Math.random() * 0.4),
            phase: Math.random() * Math.PI * 2,
            size: 14 + Math.random() * 14,
            hue: type === 'anglerfish' ? (120 + Math.random() * 120) : (160 + Math.random() * 60),
            glow: 0.5 + Math.random() * 0.5
          });
          return;
        }
        
        if (type === 'mystery' || type === 'diver2') {
          // ç”»é¢ä¸­å¤®å·¦å¯„ã‚Šã«å›ºå®šã€æ¨ªç§»å‹•ãªã—
          this.creatures.push({
            type: 'diver2',
            x: this.W * 0.35,
            y: this.H * 0.50,
            vx: 0,
            phase: Math.random() * Math.PI * 2,
            size: 1,
            facingLeft: false,  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆå³å´ï¼‰ã«å‘ã‹ã£ã¦å³å‘ã
            bubTick: 0,
          });
          return;
        }
        
        // é€šå¸¸ã®é­šï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        this.creatures.push({
          type: 'fish',
          x: rx, y: ry,
          vx: (fromRight ? -1 : 1) * (0.5 + Math.random() * 1),
          phase: Math.random() * Math.PI * 2,
          size: 10 + Math.random() * 12,
          color: `hsl(${180 + Math.random() * 60},70%,${55 + Math.random() * 20}%)`
        });
      },
      
      animate() {
        this.raf = requestAnimationFrame(() => this.animate());
        try {
          this.time += 0.016;
          
          // è¦ªè¦ç´ ã®ã‚µã‚¤ã‚ºãŒå¤‰ã‚ã£ã¦ã„ãŸã‚‰è¿½å¾“
          const wrap = this.canvas && this.canvas.parentElement;
          if (wrap) {
            const w = wrap.clientWidth || wrap.offsetWidth;
            const h = wrap.clientHeight || wrap.offsetHeight || 200;
            if (w > 0 && (w !== this.W || h !== this.H)) {
              this.W = w;
              this.H = h;
              this.canvas.width  = w;
              this.canvas.height = h;
            }
          }
          
          // æ·±åº¦ã‚’ãªã‚ã‚‰ã‹ã«è¿½å¾“
          this.currentDepth += (this.targetDepth - this.currentDepth) * 0.008;
          
          // èƒŒæ™¯è‰²ã‚’ç·šå½¢ãƒ•ã‚§ãƒ¼ãƒ‰ï¼ˆç´„2ç§’ã€60fpsæƒ³å®šã§120ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
          const lv = this.LEVELS[this.currentLevel];
          const FADE_FRAMES = 120;
          if (this.fadeProgress < 1) {
            this.fadeProgress = Math.min(1, this.fadeProgress + 1 / FADE_FRAMES);
            const t = this.fadeProgress;
            this.renderBg1  = this.lerpColor(this.fadeFrom1,   lv.bg1,  t);
            this.renderBg2  = this.lerpColor(this.fadeFrom2,   lv.bg2,  t);
            this.renderRays = this.lerpVal(this.fadeFromRay, lv.rays, t);
          }
          
          // æ·±åº¦ãƒ¡ãƒ¼ã‚¿ãƒ¼æ›´æ–°
          const dm = document.getElementById('depthMeter');
          if (dm) dm.textContent = 'â–¼ ' + Math.round(this.currentDepth) + ' m';
          
          this.draw();
          this.update();
        } catch(e) {
          console.warn('SEA animate error:', e);
        }
      },
      
      draw() {
        const { ctx, W, H, time } = this;
        
        // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆrenderBg1/2ã¯animateå†…ã§ãªã‚ã‚‰ã‹ã«è£œé–“æ¸ˆã¿ï¼‰
        const bg = ctx.createLinearGradient(0, 0, 0, H);
        bg.addColorStop(0, this.renderBg1);
        bg.addColorStop(1, this.renderBg2);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, W, H);
        
        // å…‰ç·šï¼ˆrenderRaysã¯ãªã‚ã‚‰ã‹ã«è£œé–“æ¸ˆã¿ï¼‰
        const rayStrength = this.renderRays;
        if (rayStrength > 0.02) {
          for (let i = 0; i < 5; i++) {
            const rx = W * 0.1 + (W * 0.8 / 5) * i + Math.sin(time * 0.3 + i) * 15;
            const rg = ctx.createLinearGradient(rx, 0, rx + 40, H * 0.8);
            rg.addColorStop(0, `rgba(180,230,255,${0.18 * rayStrength})`);
            rg.addColorStop(1, `rgba(180,230,255,0)`);
            ctx.beginPath();
            ctx.moveTo(rx - 15, 0);
            ctx.lineTo(rx + 40, H * 0.8);
            ctx.lineTo(rx + 55, H * 0.8);
            ctx.lineTo(rx + 0, 0);
            ctx.fillStyle = rg;
            ctx.fill();
          }
        }
        
        // æµ®éŠå¡µ
        ctx.fillStyle = 'rgba(200,230,255,0.6)';
        for (const p of this.particles) {
          ctx.globalAlpha = p.opacity;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        
        // æ³¡
        for (const b of this.bubbles) {
          const bx = b.x + Math.sin(b.wobble + time * 0.8) * 5;
          ctx.globalAlpha = b.opacity;
          ctx.beginPath();
          ctx.arc(bx, b.y, b.r, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(180,230,255,0.9)';
          ctx.lineWidth = 0.8;
          ctx.stroke();
          // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
          ctx.beginPath();
          ctx.arc(bx - b.r * 0.3, b.y - b.r * 0.3, b.r * 0.3, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        
        // è¬ã®ç©ºé–“: ç´«ã®éœ§ + æµ®éŠå…‰ç‚¹
        if (this.currentLevel === 8) {
          const fogAlpha = 0.07 + Math.sin(this.time * 0.4) * 0.03;
          ctx.fillStyle = `rgba(55,0,95,${fogAlpha})`;
          ctx.fillRect(0, 0, W, H);
          ctx.save();
          for (let s = 0; s < 20; s++) {
            const sx = ((s * 139 + this.time * 9) % W + W) % W;
            const sy = ((s * 89 + Math.sin(this.time * 0.35 + s) * 45) % H + H) % H;
            const sr = 0.7 + Math.sin(this.time * 1.1 + s * 2.3) * 0.5;
            ctx.globalAlpha = 0.14 + Math.sin(this.time * 0.9 + s) * 0.08;
            ctx.fillStyle = `hsl(${275 + s * 14},75%,78%)`;
            ctx.beginPath(); ctx.arc(sx, sy, sr, 0, Math.PI * 2); ctx.fill();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }
        
        // ç”Ÿãç‰©
        for (const c of this.creatures) {
          this.drawCreature(c);
        }
        
        // ãƒ€ã‚¤ãƒãƒ¼
        this.drawDiver();
      },
      
      drawCreature(c) {
        const { ctx, time } = this;
        if (c.type === 'fish') {
          const flip = c.vx < 0 ? -1 : 1;
          const wobble = Math.sin(time * 2 + c.phase) * 3;
          ctx.save();
          ctx.translate(c.x, c.y + wobble);
          ctx.scale(flip, 1);
          ctx.fillStyle = c.color;
          ctx.globalAlpha = 0.75;
          // èƒ´ä½“
          ctx.beginPath();
          ctx.ellipse(0, 0, c.size, c.size * 0.45, 0, 0, Math.PI * 2);
          ctx.fill();
          // å°¾ã²ã‚Œ
          ctx.beginPath();
          ctx.moveTo(-c.size * 0.85, 0);
          ctx.lineTo(-c.size * 1.5, -c.size * 0.5 + Math.sin(time * 4 + c.phase) * 3);
          ctx.lineTo(-c.size * 1.5,  c.size * 0.5 + Math.sin(time * 4 + c.phase) * 3);
          ctx.closePath();
          ctx.fill();
          // ç›®
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.beginPath();
          ctx.arc(c.size * 0.5, -c.size * 0.1, c.size * 0.12, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'jellyfish') {
          const pulse = 0.85 + Math.sin(time * 1.2 + c.phase) * 0.15;
          ctx.save();
          ctx.translate(c.x, c.y + Math.sin(time * 0.5 + c.phase) * 8);
          ctx.globalAlpha = 0.55;
          // å‚˜
          const jg = ctx.createRadialGradient(0, 0, 0, 0, 0, c.size * pulse);
          jg.addColorStop(0, `hsla(${c.hue},80%,75%,0.9)`);
          jg.addColorStop(1, `hsla(${c.hue},70%,55%,0)`);
          ctx.fillStyle = jg;
          ctx.beginPath();
          ctx.ellipse(0, 0, c.size * pulse, c.size * 0.6 * pulse, 0, Math.PI, 0);
          ctx.fill();
          // è§¦æ‰‹
          for (let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.moveTo(i * c.size * 0.2, 0);
            ctx.quadraticCurveTo(
              i * c.size * 0.2 + Math.sin(time + i) * 8,
              c.size * 0.8,
              i * c.size * 0.2 + Math.sin(time * 1.5 + i) * 12,
              c.size * 1.5
            );
            ctx.strokeStyle = `hsla(${c.hue},70%,70%,0.5)`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'anglerfish') {
          // æ·±æµ·é­šï¼ˆã‚¢ãƒ³ã‚³ã‚¦é¢¨ãƒ»ç™ºå…‰ï¼‰
          const pulse = 0.7 + Math.sin(time * 2 + c.phase) * 0.3;
          const flip = c.vx < 0 ? -1 : 1;
          ctx.save();
          ctx.translate(c.x, c.y + Math.sin(time * 0.3 + c.phase) * 5);
          ctx.scale(flip, 1);
          ctx.globalAlpha = 0.7;
          
          // ã‚°ãƒ­ãƒ¼
          const glowG = ctx.createRadialGradient(c.size * 0.8, -c.size, 0, c.size * 0.8, -c.size, c.size * 1.2 * pulse);
          glowG.addColorStop(0, `hsla(${c.hue},100%,70%,0.9)`);
          glowG.addColorStop(1, `hsla(${c.hue},100%,50%,0)`);
          ctx.fillStyle = glowG;
          ctx.beginPath();
          ctx.arc(c.size * 0.8, -c.size, c.size * 1.2 * pulse, 0, Math.PI * 2);
          ctx.fill();
          
          // èƒ´ä½“ï¼ˆæš—ã„ï¼‰
          ctx.fillStyle = `hsl(240,30%,12%)`;
          ctx.beginPath();
          ctx.ellipse(0, 0, c.size * 1.1, c.size * 0.6, 0.2, 0, Math.PI * 2);
          ctx.fill();
          
          // ç›®
          ctx.fillStyle = `hsla(${c.hue},100%,70%,${0.5 + pulse * 0.5})`;
          ctx.beginPath();
          ctx.arc(c.size * 0.6, -c.size * 0.15, c.size * 0.2, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'katsuo') {
          // ã‚«ãƒ„ã‚ªï¼ˆã‚¹ãƒªãƒ ãªç´¡éŒ˜å½¢ã€èƒŒãŒé’é»’ã€è…¹ãŒéŠ€ç™½ã€ç¸¦ç¸ï¼‰
          const flip = c.vx < 0 ? -1 : 1;
          const tailWave = Math.sin(time * 5 + c.phase) * 3;
          ctx.save();
          ctx.translate(c.x, c.y + Math.sin(time * 1.5 + c.phase) * 2);
          ctx.scale(flip, 1);
          ctx.globalAlpha = 0.82;
          
          // èƒ´ä½“ï¼ˆä¸ŠåŠåˆ†ï¼šé’é»’ï¼‰
          ctx.beginPath();
          ctx.ellipse(0, -c.size * 0.1, c.size, c.size * 0.28, 0, Math.PI, 0);
          ctx.fillStyle = '#1a2a4a';
          ctx.fill();
          
          // èƒ´ä½“ï¼ˆä¸‹åŠåˆ†ï¼šéŠ€ç™½ï¼‰
          ctx.beginPath();
          ctx.ellipse(0, c.size * 0.08, c.size, c.size * 0.22, 0, 0, Math.PI);
          ctx.fillStyle = '#c8d8e8';
          ctx.fill();
          
          // ç¸¦ç¸ï¼ˆã‚«ãƒ„ã‚ªã®ç‰¹å¾´ï¼‰
          ctx.strokeStyle = 'rgba(80,120,180,0.5)';
          ctx.lineWidth = 1;
          for (let s = 0; s < 5; s++) {
            const sx = -c.size * 0.3 + s * c.size * 0.15;
            ctx.beginPath();
            ctx.moveTo(sx, c.size * 0.05);
            ctx.lineTo(sx + c.size * 0.05, c.size * 0.28);
            ctx.stroke();
          }
          
          // å°¾ã³ã‚Œï¼ˆå¤§ããåŠ›å¼·ã„ï¼‰
          ctx.fillStyle = '#1a2a4a';
          ctx.beginPath();
          ctx.moveTo(-c.size * 0.88, 0);
          ctx.lineTo(-c.size * 1.5, -c.size * 0.45 + tailWave);
          ctx.lineTo(-c.size * 1.35, 0);
          ctx.lineTo(-c.size * 1.5,  c.size * 0.45 + tailWave);
          ctx.closePath();
          ctx.fill();
          
          // èƒŒã³ã‚Œ
          ctx.fillStyle = '#1a2a4a';
          ctx.beginPath();
          ctx.moveTo(-c.size * 0.1, -c.size * 0.22);
          ctx.lineTo( c.size * 0.4, -c.size * 0.38);
          ctx.lineTo( c.size * 0.55,-c.size * 0.22);
          ctx.closePath();
          ctx.fill();
          
          // ç›®
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(c.size * 0.65, -c.size * 0.06, c.size * 0.09, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.5)';
          ctx.beginPath();
          ctx.arc(c.size * 0.67, -c.size * 0.08, c.size * 0.035, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'diver2') {
          // 2äººç›®ã®ãƒ€ã‚¤ãƒãƒ¼ï¼ˆç™½Ã—ãƒ”ãƒ³ã‚¯ã‚¹ãƒ¼ãƒ„ï¼‰
          // é™ã‹ãªä¸Šä¸‹æµ®éŠã®ã¿ï¼ˆæ¨ªç§»å‹•ãªã—ï¼‰
          const floatY  = Math.sin(time * 0.55 + c.phase) * 7;
          const finWave = Math.sin(time * 0.9 + c.phase) * 2;   // ã‚†ã£ãã‚Šãƒ•ã‚£ãƒ³
          const armWave = Math.sin(time * 0.7 + c.phase) * 2;   // ã‚†ã£ãã‚Šè…•
          const flip = c.facingLeft ? -1 : 1;
          ctx.save();
          ctx.translate(c.x, c.y + floatY);
          ctx.scale(flip, 1);
          ctx.globalAlpha = 0.85;
          // æ³¡ï¼ˆå®šæœŸï¼‰
          c.bubTick++;
          if (c.bubTick % 55 === 0) {
            this.bubbles.push({
              x: c.x - flip * 14, y: c.y - 8,
              r: 1 + Math.random() * 2,
              speed: 0.55 + Math.random() * 0.4,
              wobble: Math.random() * Math.PI * 2,
              opacity: 0.4,
            });
          }
          // ã‚¿ãƒ³ã‚¯ï¼ˆãƒ”ãƒ³ã‚¯ï¼‰
          ctx.fillStyle = '#c05878';
          ctx.beginPath(); ctx.rect(12, -8, 7, 19); ctx.fill();
          ctx.fillStyle = '#7a3248';
          ctx.beginPath(); ctx.rect(13, -11, 5, 5); ctx.fill();
          // ãƒœãƒ‡ã‚£ï¼ˆç™½ï¼‰
          ctx.fillStyle = '#e8eef8';
          ctx.beginPath(); ctx.ellipse(0, 0, 9, 14, 0, 0, Math.PI * 2); ctx.fill();
          // ã‚¹ãƒ¼ãƒ„ã®ãƒ”ãƒ³ã‚¯ãƒ©ã‚¤ãƒ³
          ctx.strokeStyle = '#d06090'; ctx.lineWidth = 2.5;
          ctx.beginPath(); ctx.moveTo(-5, -9); ctx.lineTo(-5, 9); ctx.stroke();
          // é ­
          ctx.fillStyle = '#e8eef8';
          ctx.beginPath(); ctx.arc(0, -17, 9, 0, Math.PI * 2); ctx.fill();
          // ãƒã‚¹ã‚¯ï¼ˆæ°´è‰²ï¼‰
          ctx.fillStyle = 'rgba(140,220,255,0.65)';
          ctx.beginPath(); ctx.ellipse(0, -17, 7, 5.5, 0, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = '#d06090'; ctx.lineWidth = 1.5; ctx.stroke();
          // ãƒ•ã‚£ãƒ³ï¼ˆãƒ‘ãƒ¼ãƒ—ãƒ«ï¼‰
          ctx.fillStyle = '#8855cc';
          ctx.beginPath(); ctx.ellipse(finWave * 0.4, 19, 13, 4, -0.15, 0, Math.PI * 2); ctx.fill();
          // è…•
          ctx.strokeStyle = '#e8eef8'; ctx.lineWidth = 5; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(0, -4);
          ctx.quadraticCurveTo(18, 2 + armWave, 20, 9);
          ctx.stroke();
          // å¾®ã‹ãªã‚°ãƒ­ãƒ¼
          const glowD2 = ctx.createRadialGradient(0, 0, 4, 0, 0, 42);
          glowD2.addColorStop(0, 'rgba(210,150,255,0.10)');
          glowD2.addColorStop(1, 'rgba(210,150,255,0)');
          ctx.globalAlpha = 0.55;
          ctx.fillStyle = glowD2;
          ctx.beginPath(); ctx.arc(0, 0, 42, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'saba') {
          // ã‚µãƒï¼šç´°é•·ã„ç´¡éŒ˜å½¢ã€èƒŒãŒé’ç·‘ã®ç¸æ¨¡æ§˜
          const flip = c.vx < 0 ? -1 : 1;
          const tailWave = Math.sin(time * 4.5 + c.phase) * 2.5;
          ctx.save();
          ctx.translate(c.x, c.y + Math.sin(time * 1.2 + c.phase) * 2);
          ctx.scale(flip, 1);
          ctx.globalAlpha = 0.8;
          
          // èƒ´ä½“ä¸Šï¼ˆé’ç·‘ï¼‰
          ctx.beginPath();
          ctx.ellipse(0, -c.size * 0.08, c.size, c.size * 0.22, 0, Math.PI, 0);
          ctx.fillStyle = '#2a6e5a';
          ctx.fill();
          // èƒ´ä½“ä¸‹ï¼ˆéŠ€ï¼‰
          ctx.beginPath();
          ctx.ellipse(0, c.size * 0.06, c.size, c.size * 0.18, 0, 0, Math.PI);
          ctx.fillStyle = '#b8ccd8';
          ctx.fill();
          // é’ç·‘ã®æ–œã‚ç¸
          ctx.strokeStyle = 'rgba(20,90,70,0.6)';
          ctx.lineWidth = 1;
          for (let s = 0; s < 6; s++) {
            const sx = -c.size * 0.6 + s * c.size * 0.22;
            ctx.beginPath();
            ctx.moveTo(sx, -c.size * 0.05);
            ctx.lineTo(sx + c.size * 0.08, c.size * 0.2);
            ctx.stroke();
          }
          // å°¾ã³ã‚Œ
          ctx.fillStyle = '#2a6e5a';
          ctx.beginPath();
          ctx.moveTo(-c.size * 0.9, 0);
          ctx.lineTo(-c.size * 1.45, -c.size * 0.35 + tailWave);
          ctx.lineTo(-c.size * 1.45,  c.size * 0.35 + tailWave);
          ctx.closePath();
          ctx.fill();
          // ç›®
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(c.size * 0.65, -c.size * 0.05, c.size * 0.08, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'rakko') {
          // ãƒ©ãƒƒã‚³ï¼šä¸¸ã£ã“ã„ä½“ã€å¯æ„›ã„ã€èŒ¶è‰²ç³»
          const wobble = Math.sin(time * 0.8 + c.phase) * 3;
          const flip = c.vx < 0 ? -1 : 1;
          const armWave = Math.sin(time * 2 + c.phase) * 0.15;
          ctx.save();
          ctx.translate(c.x, c.y + wobble);
          ctx.scale(flip, 1);
          ctx.globalAlpha = 0.85;
          
          // èƒ´ä½“ï¼ˆèŒ¶è‰²ã®æ¥•å††ï¼‰
          ctx.beginPath();
          ctx.ellipse(0, 0, c.size, c.size * 0.9, 0, 0, Math.PI * 2);
          ctx.fillStyle = '#8B6F47';  // èŒ¶è‰²
          ctx.fill();
          
          // ãŠè…¹ï¼ˆè–„ã„ãƒ™ãƒ¼ã‚¸ãƒ¥ï¼‰
          ctx.beginPath();
          ctx.ellipse(c.size * 0.15, c.size * 0.15, c.size * 0.55, c.size * 0.65, 0, 0, Math.PI * 2);
          ctx.fillStyle = '#D4B896';
          ctx.fill();
          
          // é ­ï¼ˆä¸¸ï¼‰
          ctx.beginPath();
          ctx.arc(c.size * 0.7, -c.size * 0.5, c.size * 0.5, 0, Math.PI * 2);
          ctx.fillStyle = '#8B6F47';
          ctx.fill();
          
          // è€³ï¼ˆå°ã•ã„æ¥•å††Ã—2ï¼‰
          ctx.beginPath();
          ctx.ellipse(c.size * 0.5, -c.size * 0.85, c.size * 0.15, c.size * 0.18, -0.3, 0, Math.PI * 2);
          ctx.fillStyle = '#6B5737';
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(c.size * 0.88, -c.size * 0.85, c.size * 0.15, c.size * 0.18, 0.3, 0, Math.PI * 2);
          ctx.fill();
          
          // ç›®ï¼ˆã‚¯ãƒªã‚¯ãƒªã—ãŸä¸¸ã„ç›®ï¼‰
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(c.size * 0.6, -c.size * 0.55, c.size * 0.08, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(c.size * 0.82, -c.size * 0.55, c.size * 0.08, 0, Math.PI * 2);
          ctx.fill();
          // ç™½ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆ
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(c.size * 0.62, -c.size * 0.57, c.size * 0.03, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(c.size * 0.84, -c.size * 0.57, c.size * 0.03, 0, Math.PI * 2);
          ctx.fill();
          
          // é¼»ï¼ˆå°ã•ã„ä¸‰è§’ï¼‰
          ctx.fillStyle = '#4a3a2a';
          ctx.beginPath();
          ctx.moveTo(c.size * 0.71, -c.size * 0.42);
          ctx.lineTo(c.size * 0.66, -c.size * 0.35);
          ctx.lineTo(c.size * 0.76, -c.size * 0.35);
          ctx.closePath();
          ctx.fill();
          
          // ãƒ’ã‚²
          ctx.strokeStyle = 'rgba(60,50,40,0.6)';
          ctx.lineWidth = 0.6;
          for (let w = 0; w < 3; w++) {
            const wy = -c.size * 0.38 + w * c.size * 0.06;
            // å·¦å´
            ctx.beginPath();
            ctx.moveTo(c.size * 0.5, wy);
            ctx.lineTo(c.size * 0.2, wy - c.size * 0.05);
            ctx.stroke();
            // å³å´
            ctx.beginPath();
            ctx.moveTo(c.size * 0.92, wy);
            ctx.lineTo(c.size * 1.22, wy - c.size * 0.05);
            ctx.stroke();
          }
          
          // å‰è¶³ï¼ˆãŠè…¹ã®å‰ã§åˆã‚ã›ã¦ã„ã‚‹ï¼‰
          ctx.fillStyle = '#6B5737';
          ctx.beginPath();
          ctx.ellipse(c.size * 0.3, c.size * 0.3 + armWave * c.size, c.size * 0.18, c.size * 0.3, -0.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(c.size * 0.0, c.size * 0.3 - armWave * c.size, c.size * 0.18, c.size * 0.3, 0.5, 0, Math.PI * 2);
          ctx.fill();
          
          // å¾Œã‚è¶³ï¼ˆãƒ’ãƒ¬ï¼‰
          ctx.beginPath();
          ctx.ellipse(-c.size * 0.5, c.size * 0.6, c.size * 0.25, c.size * 0.15, 0.3, 0, Math.PI * 2);
          ctx.fillStyle = '#6B5737';
          ctx.fill();
          
          // å°¾ï¼ˆå°ã•ã„ï¼‰
          ctx.beginPath();
          ctx.ellipse(-c.size * 0.85, c.size * 0.05, c.size * 0.2, c.size * 0.15, 0, 0, Math.PI * 2);
          ctx.fillStyle = '#8B6F47';
          ctx.fill();
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'shark') {
          // ã‚µãƒ¡ï¼šå¤§ãã„ã€ä¸‰è§’èƒŒã³ã‚Œã€æµç·šå‹
          const flip = c.vx < 0 ? -1 : 1;
          const tailWave = Math.sin(time * 2.5 + c.phase) * 4;
          ctx.save();
          ctx.translate(c.x, c.y + Math.sin(time * 0.5 + c.phase) * 3);
          ctx.scale(flip, 1);
          ctx.globalAlpha = 0.75;
          
          // èƒ´ä½“
          ctx.beginPath();
          ctx.ellipse(0, 0, c.size, c.size * 0.3, 0, 0, Math.PI * 2);
          ctx.fillStyle = '#607080';
          ctx.fill();
          // è…¹ï¼ˆç™½ï¼‰
          ctx.beginPath();
          ctx.ellipse(c.size * 0.1, c.size * 0.1, c.size * 0.75, c.size * 0.16, 0, 0, Math.PI);
          ctx.fillStyle = '#d8dde0';
          ctx.fill();
          // ä¸‰è§’èƒŒã³ã‚Œï¼ˆç‰¹å¾´çš„ï¼‰
          ctx.beginPath();
          ctx.moveTo(c.size * 0.1, -c.size * 0.28);
          ctx.lineTo(c.size * 0.45, -c.size * 0.72);
          ctx.lineTo(c.size * 0.6, -c.size * 0.28);
          ctx.closePath();
          ctx.fillStyle = '#506070';
          ctx.fill();
          // å°¾ã³ã‚Œï¼ˆä¸‰æ—¥æœˆå‹ï¼‰
          ctx.fillStyle = '#506070';
          ctx.beginPath();
          ctx.moveTo(-c.size * 0.85, 0);
          ctx.lineTo(-c.size * 1.55, -c.size * 0.5 + tailWave);
          ctx.lineTo(-c.size * 1.2, 0);
          ctx.lineTo(-c.size * 1.55,  c.size * 0.5 + tailWave);
          ctx.closePath();
          ctx.fill();
          // èƒ¸ã³ã‚Œ
          ctx.beginPath();
          ctx.moveTo(c.size * 0.2, c.size * 0.15);
          ctx.lineTo(-c.size * 0.1, c.size * 0.55);
          ctx.lineTo(-c.size * 0.3, c.size * 0.15);
          ctx.closePath();
          ctx.fillStyle = '#607080';
          ctx.fill();
          // ç›®
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.arc(c.size * 0.6, -c.size * 0.08, c.size * 0.07, 0, Math.PI * 2);
          ctx.fill();
          // ãˆã‚‰
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 1;
          for (let g = 0; g < 3; g++) {
            const gx = c.size * 0.35 - g * c.size * 0.1;
            ctx.beginPath();
            ctx.moveTo(gx, -c.size * 0.22);
            ctx.lineTo(gx - c.size * 0.05, c.size * 0.12);
            ctx.stroke();
          }
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'shrimp') {
          // ã‚¨ãƒ“ï¼šç´°ã„ä½“ãŒå¼§ã‚’æãã€è§¦è§’ã€è„š
          const flip = c.vx < 0 ? -1 : 1;
          const bob = Math.sin(time * 3 + c.phase) * 2;
          ctx.save();
          ctx.translate(c.x, c.y + bob);
          ctx.scale(flip, 1);
          ctx.globalAlpha = 0.8;
          
          // èƒ´ä½“ï¼ˆå¼§çŠ¶ã®æ¥•å††ã‚’é€£ã­ã‚‹ï¼‰
          ctx.fillStyle = '#e87060';
          for (let seg = 0; seg < 5; seg++) {
            const sx = c.size * 0.3 - seg * c.size * 0.14;
            const sy = Math.sin(seg * 0.6 + c.phase) * c.size * 0.15;
            ctx.beginPath();
            ctx.ellipse(sx, sy, c.size * 0.18, c.size * 0.12, -seg * 0.15, 0, Math.PI * 2);
            ctx.fill();
          }
          // é ­éƒ¨ï¼ˆå¤§ãã‚ï¼‰
          ctx.beginPath();
          ctx.ellipse(c.size * 0.55, 0, c.size * 0.3, c.size * 0.22, 0, 0, Math.PI * 2);
          ctx.fillStyle = '#d05848';
          ctx.fill();
          // è§¦è§’
          ctx.strokeStyle = 'rgba(200,80,60,0.7)';
          ctx.lineWidth = 0.8;
          ctx.beginPath();
          ctx.moveTo(c.size * 0.75, -c.size * 0.1);
          ctx.lineTo(c.size * 1.3, -c.size * 0.45);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(c.size * 0.75, 0);
          ctx.lineTo(c.size * 1.4, -c.size * 0.2);
          ctx.stroke();
          // è„šï¼ˆå°ã•ã„ï¼‰
          ctx.strokeStyle = 'rgba(200,80,60,0.5)';
          ctx.lineWidth = 0.6;
          for (let leg = 0; leg < 4; leg++) {
            const lx = c.size * 0.2 - leg * c.size * 0.13;
            ctx.beginPath();
            ctx.moveTo(lx, c.size * 0.1);
            ctx.lineTo(lx - c.size * 0.05, c.size * 0.35 + Math.sin(time * 4 + leg) * 3);
            ctx.stroke();
          }
          // å°¾æ‰‡
          ctx.fillStyle = '#e87060';
          ctx.beginPath();
          ctx.moveTo(-c.size * 0.45, 0);
          ctx.lineTo(-c.size * 0.85, -c.size * 0.28);
          ctx.lineTo(-c.size * 0.7, 0);
          ctx.lineTo(-c.size * 0.85,  c.size * 0.28);
          ctx.closePath();
          ctx.fill();
          // ç›®
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.arc(c.size * 0.75, -c.size * 0.06, c.size * 0.07, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'starfish') {
          // ãƒ’ãƒˆãƒ‡ï¼š5æœ¬è…•ã€ã‚†ã£ãã‚Šå›è»¢
          const rot = time * 0.15 + c.phase;
          const pulse = 1 + Math.sin(time * 0.8 + c.phase) * 0.05;
          ctx.save();
          ctx.translate(c.x, c.y + Math.sin(time * 0.4 + c.phase) * 3);
          ctx.rotate(rot);
          ctx.globalAlpha = 0.82;
          
          // 5æœ¬è…•
          ctx.fillStyle = `hsl(${c.hue},80%,55%)`;
          for (let arm = 0; arm < 5; arm++) {
            const angle = (arm / 5) * Math.PI * 2 - Math.PI / 2;
            ctx.save();
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.ellipse(0, -c.size * 0.55 * pulse, c.size * 0.22, c.size * 0.55, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
          // ä¸­å¿ƒå††
          ctx.beginPath();
          ctx.arc(0, 0, c.size * 0.28 * pulse, 0, Math.PI * 2);
          ctx.fillStyle = `hsl(${c.hue},70%,45%)`;
          ctx.fill();
          // ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼ˆå°ã•ã„ç‚¹ï¼‰
          ctx.fillStyle = `hsla(${c.hue},60%,35%,0.5)`;
          for (let arm = 0; arm < 5; arm++) {
            const angle = (arm / 5) * Math.PI * 2 - Math.PI / 2;
            for (let d = 1; d <= 3; d++) {
              ctx.beginPath();
              ctx.arc(
                Math.cos(angle) * c.size * 0.2 * d,
                Math.sin(angle) * c.size * 0.2 * d,
                c.size * 0.05, 0, Math.PI * 2
              );
              ctx.fill();
            }
          }
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'seaweed') {
          // ã‚ã‹ã‚ï¼šåº•ã‹ã‚‰ç”Ÿãˆã€å·¦å³ã«ã‚†ã‚‰ã‚†ã‚‰
          ctx.save();
          ctx.translate(c.x, c.y);
          ctx.globalAlpha = 0.7;
          
          const segments = 7;
          const segH = c.size / segments;
          ctx.strokeStyle = `hsl(${c.hue},65%,30%)`;
          ctx.lineWidth = c.size * 0.12;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // æœ¬ä½“ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šã§ã‚†ã‚‰ã‚†ã‚‰ï¼‰
          ctx.beginPath();
          ctx.moveTo(0, 0);
          for (let s = 1; s <= segments; s++) {
            const sy = -segH * s;
            const wave = Math.sin(time * 1.2 + c.phase + s * 0.5) * (c.size * 0.18);
            ctx.lineTo(wave, sy);
          }
          ctx.strokeStyle = `hsl(${c.hue},60%,28%)`;
          ctx.stroke();
          
          // è‘‰ï¼ˆæ¨ªã«åºƒãŒã‚‹å¸¯ï¼‰
          for (let s = 2; s <= segments; s += 2) {
            const sy = -segH * s;
            const wave = Math.sin(time * 1.2 + c.phase + s * 0.5) * (c.size * 0.18);
            const leafW = c.size * (0.15 + 0.08 * s / segments);
            const leafWave = Math.sin(time * 1.5 + c.phase + s) * leafW * 0.4;
            ctx.beginPath();
            ctx.ellipse(wave + leafWave, sy, leafW, c.size * 0.07, Math.sin(time + s) * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${c.hue},65%,32%,0.8)`;
            ctx.fill();
          }
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'clam') {
          // ã‚¢ã‚µãƒªï¼šä¸¸ã¿ã®ã‚ã‚‹ä¸‰è§’å½¢ã®äºŒæšè²ã€åŒå¿ƒå††ã®æ¨¡æ§˜
          const bob = Math.sin(time * 0.5 + c.phase) * 1;
          ctx.save();
          ctx.translate(c.x, c.y + bob);
          ctx.globalAlpha = 0.85;
          
          // ä¸‹ã®è²æ®»
          ctx.beginPath();
          ctx.ellipse(0, c.size * 0.1, c.size, c.size * 0.45, 0, 0, Math.PI);
          ctx.fillStyle = '#c8b090';
          ctx.fill();
          // ä¸Šã®è²æ®»
          ctx.beginPath();
          ctx.ellipse(0, 0, c.size, c.size * 0.55, 0, Math.PI, 0);
          ctx.fillStyle = '#d8c0a0';
          ctx.fill();
          // åŒå¿ƒå††ã®ç­‹
          ctx.strokeStyle = 'rgba(150,110,70,0.5)';
          ctx.lineWidth = 0.7;
          for (let r2 = 1; r2 <= 3; r2++) {
            ctx.beginPath();
            ctx.ellipse(0, 0, c.size * (0.35 + r2 * 0.22), c.size * (0.2 + r2 * 0.12), 0, Math.PI, 0);
            ctx.stroke();
          }
          // è¶ç•ªã®ç‚¹
          ctx.fillStyle = '#907050';
          ctx.beginPath();
          ctx.arc(0, 0, c.size * 0.1, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
        } else if (c.type === 'mussel') {
          // ãƒ ãƒ¼ãƒ«è²ï¼šç¸¦é•·ã®æ¥•å††ã€ç´«ã€œé»’ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
          const bob = Math.sin(time * 0.4 + c.phase) * 1.5;
          ctx.save();
          ctx.translate(c.x, c.y + bob);
          ctx.rotate(Math.sin(time * 0.3 + c.phase) * 0.1);
          ctx.globalAlpha = 0.85;
          
          // å¤–å´
          const musselGrad = ctx.createLinearGradient(-c.size * 0.4, -c.size, c.size * 0.4, c.size);
          musselGrad.addColorStop(0, '#3a2060');
          musselGrad.addColorStop(0.5, '#6040a0');
          musselGrad.addColorStop(1, '#1a0830');
          ctx.beginPath();
          ctx.ellipse(0, 0, c.size * 0.42, c.size, 0, 0, Math.PI * 2);
          ctx.fillStyle = musselGrad;
          ctx.fill();
          // å…‰æ²¢
          const sheen = ctx.createLinearGradient(-c.size * 0.2, -c.size * 0.8, c.size * 0.1, 0);
          sheen.addColorStop(0, 'rgba(180,150,255,0.3)');
          sheen.addColorStop(1, 'rgba(180,150,255,0)');
          ctx.fillStyle = sheen;
          ctx.beginPath();
          ctx.ellipse(-c.size * 0.1, -c.size * 0.3, c.size * 0.18, c.size * 0.5, -0.3, 0, Math.PI * 2);
          ctx.fill();
          // ç¸¦ã®ç­‹
          ctx.strokeStyle = 'rgba(80,40,120,0.6)';
          ctx.lineWidth = 0.8;
          ctx.beginPath();
          ctx.moveTo(0, -c.size * 0.9);
          ctx.lineTo(0, c.size * 0.9);
          ctx.stroke();
          
          ctx.restore();
          ctx.globalAlpha = 1;
        }
      },
      
      drawDiver() {
        const { ctx, W, H, time } = this;
        // ãƒ€ã‚¤ãƒãƒ¼ã¯canvasä¸­å¤®å³å¯„ã‚Šã«é…ç½®
        const dx = W * 0.72;
        const dy = H * 0.5 + Math.sin(time * 0.6) * 6;
        
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.translate(dx, dy);
        
        // æ³¡ï¼ˆãƒ€ã‚¤ãƒãƒ¼ã‹ã‚‰ï¼‰
        if (Math.random() < 0.04) {
          this.bubbles.push({ x: dx - 14, y: dy - 8, r: 1 + Math.random() * 2, speed: 0.6 + Math.random() * 0.5, wobble: Math.random() * Math.PI * 2, opacity: 0.4 });
        }
        
        // ã‚¿ãƒ³ã‚¯
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.rect(-18, -8, 7, 18);
        ctx.fill();
        
        // ãƒœãƒ‡ã‚£ï¼ˆã‚¦ã‚§ãƒƒãƒˆã‚¹ãƒ¼ãƒ„ï¼‰
        ctx.fillStyle = '#1a3a5c';
        ctx.beginPath();
        ctx.ellipse(-4, 0, 9, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // é ­ãƒ»ãƒã‚¹ã‚¯
        ctx.fillStyle = '#1a3a5c';
        ctx.beginPath();
        ctx.arc(-4, -16, 9, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(100,200,255,0.6)';
        ctx.beginPath();
        ctx.ellipse(-4, -16, 7, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ãƒ•ã‚£ãƒ³ï¼ˆæ³¢æ‰“ã¤ï¼‰
        ctx.fillStyle = '#f5a623';
        const finWave = Math.sin(time * 1.8) * 4;
        ctx.beginPath();
        ctx.ellipse(-4 + finWave, 18, 14, 4, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // è…•
        ctx.strokeStyle = '#1a3a5c';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-4, -4);
        ctx.quadraticCurveTo(-20, 2 + Math.sin(time * 1.2) * 3, -22, 8);
        ctx.stroke();
        
        ctx.restore();
        ctx.globalAlpha = 1;
      },
      
      update() {
        const { H, W, time } = this;
        const lv = this.LEVELS[this.currentLevel];
        
        // æ³¡ã‚’ä¸Šã¸
        for (let i = this.bubbles.length - 1; i >= 0; i--) {
          this.bubbles[i].y -= this.bubbles[i].speed;
          this.bubbles[i].wobble += 0.03;
          if (this.bubbles[i].y < -10) {
            this.bubbles.splice(i, 1);
            if (this.bubbles.length < 18) this.addBubble(false);
          }
        }
        
        // æµ®éŠå¡µã‚’ã‚†ã£ãã‚Šä¸‹ã¸
        for (let i = this.particles.length - 1; i >= 0; i--) {
          this.particles[i].y += this.particles[i].vy;
          this.particles[i].x += this.particles[i].vx;
          if (this.particles[i].y > H + 5) {
            this.particles.splice(i, 1);
            if (this.particles.length < 30) this.addParticle(false);
          }
        }
        
        // ç”Ÿãç‰©ã‚’ç§»å‹•
        const types = lv.creatures;
        for (let i = this.creatures.length - 1; i >= 0; i--) {
          const c = this.creatures[i];
          // ã‚ã‹ã‚ã¯å›ºå®šã€è²é¡ã¯ã»ã¼å›ºå®šãªã®ã§ç”»é¢å¤–åˆ¤å®šã—ãªã„
          if (c.type === 'seaweed' || c.type === 'clam' || c.type === 'mussel') continue;
          // diver2ã¯å›ºå®šä½ç½®ãƒ»æ¨ªç§»å‹•ãªã—
          if (c.type === 'diver2') continue;
          c.x += c.vx;
          if (c.x < -120 || c.x > W + 120) {
            this.creatures.splice(i, 1);
            const type = types[Math.floor(Math.random() * types.length)];
            this.addCreature(type, false);
          }
        }
        // diver2ã‚¹ãƒ†ãƒ¼ã‚¸ã¯1ä½“å›ºå®šãƒ»è£œå……ãªã—ï¼ˆç”»é¢å¤–ã«å‡ºãªã„ãŸã‚ä¸è¦ï¼‰
        if (!types.includes('diver2')) {
          const isSparse = types.includes('anglerfish') || types.includes('rakko');
          const minCount = isSparse ? 2 : 3;
          if (this.creatures.length < minCount) {
            const type = types[Math.floor(Math.random() * types.length)];
            this.addCreature(type, false);
          }
        }
      },
      
      // è‰²è£œé–“ï¼ˆ16é€² or rgbï¼‰
      lerpColor(a, b, t) {
        const pa = this.hexToRgb(a), pb = this.hexToRgb(b);
        const r = Math.round(pa.r + (pb.r - pa.r) * t);
        const g = Math.round(pa.g + (pb.g - pa.g) * t);
        const bl = Math.round(pa.b + (pb.b - pa.b) * t);
        return `rgb(${r},${g},${bl})`;
      },
      
      hexToRgb(hex) {
        // rgb(...) å½¢å¼ã«ã‚‚å¯¾å¿œ
        if (hex.startsWith('rgb')) {
          const m = hex.match(/\d+/g);
          return { r: +m[0], g: +m[1], b: +m[2] };
        }
        const m = hex.replace('#','').match(/.{2}/g);
        return { r: parseInt(m[0],16), g: parseInt(m[1],16), b: parseInt(m[2],16) };
      },
      
      lerpVal(a, b, t) { return a + (b - a) * t; },
      
      stop() {
        if (this.raf) cancelAnimationFrame(this.raf);
        this.raf = null;
      }
    };
    
    // èµ·å‹•
    SEA.init();
    init();

    // ä¸­æ–­botan
    document.getElementById('abortBtn').addEventListener('click', () => {
      if (confirm('ã‚²ãƒ¼ãƒ ã‚’ä¸­æ–­ã—ã¾ã™ã‹ï¼Ÿ')) {
        window.location.href = './index.html';
      }
    });
  </script>
</body>
</html>
